/*******************************************************************************
 * Copyright (C) 2024 MINRES Technologies GmbH
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *******************************************************************************/

// clang-format off
#include <cstdint>
#include <iss/arch/rv32gcv.h>
#include <iss/debugger/gdb_session.h>
#include <iss/debugger/server.h>
#include <iss/iss.h>
#include <iss/interp/vm_base.h>

#include <fp_functions.h>

#include <vm/vector_functions.h>


#include <util/logging.h>
#include <boost/coroutine2/all.hpp>
#include <functional>
#include <exception>
#include <vector>
#include <sstream>
#include <iss/instruction_decoder.h>


#ifndef FMT_HEADER_ONLY
#define FMT_HEADER_ONLY
#endif
#include <fmt/format.h>

#include <array>
#include <iss/debugger/riscv_target_adapter.h>

namespace iss {
namespace interp {
namespace rv32gcv {

using namespace iss::arch;
using namespace iss::debugger;
using namespace std::placeholders;

struct memory_access_exception : public std::exception{
    memory_access_exception(){}
};

template <typename ARCH> class vm_impl : public iss::interp::vm_base<ARCH> {
public:
    using traits = arch::traits<ARCH>;
    using super       = typename iss::interp::vm_base<ARCH>;
    using virt_addr_t = typename super::virt_addr_t;
    using phys_addr_t = typename super::phys_addr_t;
    using code_word_t = typename super::code_word_t;
    using addr_t      = typename super::addr_t;
    using reg_t       = typename traits::reg_t;
    using mem_type_e  = typename traits::mem_type_e;
    using opcode_e    = typename traits::opcode_e;


    static constexpr auto& vlseg = softvec_if::vlseg<traits::VLEN>;
    static constexpr auto& vsseg = softvec_if::vsseg<traits::VLEN>;
    static constexpr auto& vlsseg = softvec_if::vlsseg<traits::VLEN>;
    static constexpr auto& vssseg = softvec_if::vssseg<traits::VLEN>;
    static constexpr auto& vlxseg = softvec_if::vlxseg<traits::VLEN, traits::XLEN>;
    static constexpr auto& vsxseg = softvec_if::vsxseg<traits::VLEN, traits::XLEN>;
    static constexpr auto& vector_vector_op = softvec_if::vector_vector_op<traits::VLEN>;
    static constexpr auto& vector_imm_op = softvec_if::vector_imm_op<traits::VLEN>;
    static constexpr auto& vector_vector_wv = softvec_if::vector_vector_wv<traits::VLEN>;
    static constexpr auto& vector_imm_wv = softvec_if::vector_imm_wv<traits::VLEN>;
    static constexpr auto& vector_vector_ww = softvec_if::vector_vector_ww<traits::VLEN>;
    static constexpr auto& vector_imm_ww = softvec_if::vector_imm_ww<traits::VLEN>;
    static constexpr auto& vector_extend = softvec_if::vector_extend<traits::VLEN>;
    static constexpr auto& vector_vector_carry = softvec_if::vector_vector_carry<traits::VLEN>;
    static constexpr auto& vector_imm_carry = softvec_if::vector_imm_carry<traits::VLEN>;
    static constexpr auto& carry_vector_vector_op = softvec_if::carry_vector_vector_op<traits::VLEN>;
    static constexpr auto& carry_vector_imm_op = softvec_if::carry_vector_imm_op<traits::VLEN>;
    static constexpr auto& mask_vector_vector_op = softvec_if::mask_vector_vector_op<traits::VLEN>;
    static constexpr auto& mask_vector_imm_op = softvec_if::mask_vector_imm_op<traits::VLEN>;
    static constexpr auto& vector_vector_vw = softvec_if::vector_vector_vw<traits::VLEN>;
    static constexpr auto& vector_imm_vw = softvec_if::vector_imm_vw<traits::VLEN>;
    static constexpr auto& vector_vector_merge = softvec_if::vector_vector_merge<traits::VLEN>;
    static constexpr auto& vector_imm_merge = softvec_if::vector_imm_merge<traits::VLEN>;
    static constexpr auto& sat_vector_vector_op = softvec_if::sat_vector_vector_op<traits::VLEN>;
    static constexpr auto& sat_vector_imm_op = softvec_if::sat_vector_imm_op<traits::VLEN>;
    static constexpr auto& sat_vector_vector_vw = softvec_if::sat_vector_vector_vw<traits::VLEN>;
    static constexpr auto& sat_vector_imm_vw = softvec_if::sat_vector_imm_vw<traits::VLEN>;
    static constexpr auto& vector_red_op = softvec_if::vector_red_op<traits::VLEN>;
    static constexpr auto& vector_red_wv = softvec_if::vector_red_wv<traits::VLEN>;
    static constexpr auto& mask_mask_op = softvec_if::mask_mask_op<traits::VLEN>;
    static constexpr auto& vcpop = softvec_if::vcpop<traits::VLEN>;
    static constexpr auto& vfirst = softvec_if::vfirst<traits::VLEN>;
    static constexpr auto& mask_set_op = softvec_if::mask_set_op<traits::VLEN>;
    static constexpr auto& viota = softvec_if::viota<traits::VLEN>;
    static constexpr auto& vid = softvec_if::vid<traits::VLEN>;
    static constexpr auto& scalar_to_vector = softvec_if::scalar_to_vector<traits::VLEN>;
    static constexpr auto& scalar_from_vector = softvec_if::scalar_from_vector<traits::VLEN>;
    static constexpr auto& vector_slideup = softvec_if::vector_slideup<traits::VLEN>;
    static constexpr auto& vector_slidedown = softvec_if::vector_slidedown<traits::VLEN>;
    static constexpr auto& vector_slide1up = softvec_if::vector_slide1up<traits::VLEN>;
    static constexpr auto& vector_slide1down = softvec_if::vector_slide1down<traits::VLEN>;
    static constexpr auto& vector_vector_gather = softvec_if::vector_vector_gather<traits::VLEN>;
    static constexpr auto& vector_vector_gatherei16 = softvec_if::vector_vector_gatherei16<traits::VLEN>;
    static constexpr auto& vector_imm_gather = softvec_if::vector_imm_gather<traits::VLEN>;
    static constexpr auto& vector_compress = softvec_if::vector_compress<traits::VLEN>;
    static constexpr auto& vector_whole_move = softvec_if::vector_whole_move<traits::VLEN>;
    static constexpr auto& fp_scalar_from_vector = softvec_if::fp_scalar_from_vector<traits::VLEN>;
    static constexpr auto& fp_vector_slide1up = softvec_if::fp_vector_slide1up<traits::VLEN>;
    static constexpr auto& fp_vector_slide1down = softvec_if::fp_vector_slide1down<traits::VLEN>;
    static constexpr auto& fp_vector_red_op = softvec_if::fp_vector_red_op<traits::VLEN>;
    static constexpr auto& fp_vector_red_wv = softvec_if::fp_vector_red_wv<traits::VLEN>;
    static constexpr auto& fp_vector_vector_op = softvec_if::fp_vector_vector_op<traits::VLEN>;
    static constexpr auto& fp_vector_imm_op = softvec_if::fp_vector_imm_op<traits::VLEN>;
    static constexpr auto& fp_vector_vector_wv = softvec_if::fp_vector_vector_wv<traits::VLEN>;
    static constexpr auto& fp_vector_imm_wv = softvec_if::fp_vector_imm_wv<traits::VLEN>;
    static constexpr auto& fp_vector_vector_ww = softvec_if::fp_vector_vector_ww<traits::VLEN>;
    static constexpr auto& fp_vector_imm_ww = softvec_if::fp_vector_imm_ww<traits::VLEN>;
    static constexpr auto& fp_vector_unary_op = softvec_if::fp_vector_unary_op<traits::VLEN>;
    static constexpr auto& mask_fp_vector_vector_op = softvec_if::mask_fp_vector_vector_op<traits::VLEN>;
    static constexpr auto& mask_fp_vector_imm_op = softvec_if::mask_fp_vector_imm_op<traits::VLEN>;
    static constexpr auto& fp_vector_imm_merge = softvec_if::fp_vector_imm_merge<traits::VLEN>;
    static constexpr auto& fp_vector_unary_w = softvec_if::fp_vector_unary_w<traits::VLEN>;
    static constexpr auto& fp_vector_unary_n = softvec_if::fp_vector_unary_n<traits::VLEN>;
    static constexpr auto& vector_unary_op = softvec_if::vector_unary_op<traits::VLEN>;
    static constexpr auto& vector_vector_crypto = softvec_if::vector_vector_crypto<traits::VLEN>;
    static constexpr auto& vector_scalar_crypto = softvec_if::vector_scalar_crypto<traits::VLEN>;
    static constexpr auto& vector_imm_crypto = softvec_if::vector_imm_crypto<traits::VLEN>;
    static constexpr auto& vector_crypto = softvec_if::vector_crypto<traits::VLEN>;

    vm_impl();

    vm_impl(ARCH &core, unsigned core_id = 0, unsigned cluster_id = 0);

    void enableDebug(bool enable) { super::sync_exec = super::ALL_SYNC; }

    target_adapter_if *accquire_target_adapter(server_if *srv) override {
        debugger_if::dbg_enabled = true;
        if (super::tgt_adapter == nullptr)
            super::tgt_adapter = new riscv_target_adapter<ARCH>(srv, this->get_arch());
        return super::tgt_adapter;
    }

protected:
    using this_class = vm_impl<ARCH>;
    using compile_ret_t = virt_addr_t;
    using compile_func = compile_ret_t (this_class::*)(virt_addr_t &pc, code_word_t instr);

    inline const char *name(size_t index){return traits::reg_aliases.at(index);}

    inline const char *fname(size_t index){return index < 32?name(index+traits::F0):"illegal";}     

    inline const char* vname(size_t index) { return index < 32 ? name(index + traits::V0) : "illegal"; }
    inline const char* sew_name(size_t bits) {
        switch(bits) {
        case 0b000:
            return "e8";
        case 0b001:
            return "e16";
        case 0b010:
            return "e32";
        case 0b011:
            return "e64";
        default:
            return "illegal";
        }
    }
    inline const char* lmul_name(size_t bits) {
        switch(bits) {
        case 0b101:
            return "mf8";
        case 0b110:
            return "mf4";
        case 0b111:
            return "mf2";
        case 0b000:
            return "m1";
        case 0b001:
            return "m2";
        case 0b010:
            return "m4";
        case 0b011:
            return "m8";
        default:
            return "illegal";
        }
    }
    inline const char* ma_name(bool ma) { return ma ? "ma" : "mu"; }
    inline const char* ta_name(bool ta) { return ta ? "ta" : "tu"; }
    inline void lower(){
        this->core.reg.trap_state = 0;
    }


    virt_addr_t execute_inst(finish_cond_e cond, virt_addr_t start, uint64_t icount_limit) override;

    // some compile time constants

    inline void raise(uint16_t trap_id, uint16_t cause){
        auto trap_val =  0x80ULL << 24 | (cause << 16) | trap_id;
        this->core.reg.trap_state = trap_val;
    }

    inline void leave(unsigned lvl){
        this->core.leave_trap(lvl);
    }

    inline void wait(unsigned type){
        this->core.wait_until(type);
    }

    inline void set_tval(uint64_t new_tval){
        tval = new_tval;
    }
    uint64_t fetch_count{0};
    uint64_t tval{0};

    using yield_t = boost::coroutines2::coroutine<void>::push_type;
    using coro_t = boost::coroutines2::coroutine<void>::pull_type;
    std::vector<coro_t> spawn_blocks;

    template<unsigned W, typename U, typename S = typename std::make_signed<U>::type>
    inline S sext(U from) {
        auto mask = (1ULL<<W) - 1;
        auto sign_mask = 1ULL<<(W-1);
        return (from & mask) | ((from & sign_mask) ? ~mask : 0);
    }
    
    inline void process_spawn_blocks() {
        if(spawn_blocks.size()==0) return;
        for(auto it = std::begin(spawn_blocks); it!=std::end(spawn_blocks);)
             if(*it){
                 (*it)();
                 ++it;
             } else
                 spawn_blocks.erase(it);
    }

    uint64_t NaNBox32(uint32_t val){
        if(traits::FLEN == 32) {
            return (uint64_t)val;
        }
        else {
            uint64_t box = ~((uint64_t)0);
            return (uint64_t)(((uint128_t)box<<32)|val);
        }
    }

    uint8_t get_rm(uint8_t rm){
        auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+::iss::arch::traits<ARCH>::reg_byte_offsets[::iss::arch::traits<ARCH>::FCSR]); 
        uint8_t rm_eff = rm == 7? bit_sub<5, 7-5+1>(*FCSR) : rm;
        if(rm_eff > 4) {
            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
        }
        return rm_eff;
    }

    uint64_t NaNBox64(uint64_t val){
        if(traits::FLEN == 64) {
            return (uint64_t)val;
        }
        else {
            uint64_t box = ~((uint64_t)0);
            return (uint64_t)(((uint128_t)box<<64)|val);
        }
    }

    uint8_t get_pow(uint32_t val){
        switch(val){
        case 8: 
            return 3;
        case 16: 
            return 4;
        case 32: 
            return 5;
        case 64: 
            return 6;
        case 128: 
            return 7;
        case 256: 
            return 8;
        case 512: 
            return 9;
        case 1024: 
            return 10;
        case 2048: 
            return 11;
        case 4096: 
            return 12;
        default: 
            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
        }
        return 0;
    }

    uint8_t lmul(){
        auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+::iss::arch::traits<ARCH>::reg_byte_offsets[::iss::arch::traits<ARCH>::vtype]); 
        return bit_sub<0, 2-0+1>(*vtype);
    }

    uint8_t sew(){
        auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+::iss::arch::traits<ARCH>::reg_byte_offsets[::iss::arch::traits<ARCH>::vtype]); 
        return bit_sub<3, 5-3+1>(*vtype);
    }

    int8_t get_lmul_pow(){
        switch(lmul()){
        case 5: 
            return - 3;
        case 6: 
            return - 2;
        case 7: 
            return - 1;
        case 0: 
            return 0;
        case 1: 
            return 1;
        case 2: 
            return 2;
        case 3: 
            return 3;
        default: 
            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
        }
        return 0;
    }

    uint8_t get_sew_pow(){
        switch(sew()){
        case 0: 
            return 3;
        case 1: 
            return 4;
        case 2: 
            return 5;
        case 3: 
            return 6;
        default: 
            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
        }
        return 0;
    }

    uint16_t get_elem_count(){
        uint8_t total_pow = (uint8_t)((uint16_t)(get_pow(traits::VLEN)) + (int16_t)(get_lmul_pow()) - (uint16_t)(get_sew_pow()));
        return (uint16_t)(1 << total_pow) & ~1;
    }

    uint8_t valid_vtype(){
        auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+::iss::arch::traits<ARCH>::reg_byte_offsets[::iss::arch::traits<ARCH>::vtype]); 
        return bit_sub<uint32_t>(*vtype, (uint64_t)(traits::XLEN) - (uint64_t)(1), 1) == 0;
    }

    uint8_t valid_rd_mask(uint8_t rd, uint8_t vm){
        return rd != 0 || vm != 0;
    }

    uint8_t valid_eew_emul(uint8_t EEW, int8_t EMUL_pow){
        return EEW >= 8 && EEW <= traits::ELEN && EEW <= traits::EEW_MAX && EMUL_pow >= - 3 && EMUL_pow <= 3;
    }

    uint8_t valid_segment(uint8_t nf, int8_t EMUL_pow){
        if(EMUL_pow < 0) {
            uint8_t neg_EMUL = (uint8_t)(1 << - EMUL_pow) & ~1;
            return nf / neg_EMUL <= 8;
        }
        else {
            uint8_t EMUL = (uint8_t)(1 << EMUL_pow) & ~1;
            return (uint16_t)(nf) * (uint16_t)(EMUL) <= 8;
        }
    }

    uint8_t illegal_vd_unmasked(){
        return ! valid_vtype();
    }

    uint8_t illegal_variable_width(uint8_t vd, uint8_t vm, uint8_t SEW_new, int8_t LMUL_pow_new){
        return ! (valid_vtype()) || ! (valid_rd_mask(vd, vm)) || ! (valid_eew_emul(SEW_new, LMUL_pow_new));
    }

    uint8_t valid_reg_overlap(uint8_t rs, uint8_t rd, int8_t EMUL_pow_rs, int8_t EMUL_pow_rd){
        uint8_t rs_group = EMUL_pow_rs > 0? (uint8_t)(1 << EMUL_pow_rs) & (~1)& ((1ULL << 5)-1) : 1;
        uint8_t rd_group = EMUL_pow_rd > 0? (uint8_t)(1 << EMUL_pow_rd) & (~1)& ((1ULL << 5)-1) : 1;
        if(EMUL_pow_rs < EMUL_pow_rd) {
            return (rs + rs_group <= rd) || (rs >= rd + rd_group) || ((rs + rs_group == rd + rd_group) & (EMUL_pow_rs >= 0));
        }
        else {
            if(EMUL_pow_rs > EMUL_pow_rd) {
                return (rd <= rs) || (rd >= rs + rs_group);
            }
            else {
                return  true;
            }
        }
    }

    uint8_t illegal_vd_masked(uint8_t vd){
        return ! (valid_vtype()) || vd == 0;
    }

    uint8_t illegal_normal(uint8_t vd, uint8_t vm){
        return ! (valid_vtype()) || ! (valid_rd_mask(vd, vm));
    }

    uint8_t valid_fp_op(uint8_t SEW, uint8_t rm){
        int8_t valid_sew = (traits::FP_SEW_MIN >= 32 & SEW <= traits::FP_SEW_MAX);
        int8_t valid_rm = ! (rm == 5 | rm == 6 | rm == 7);
        return valid_sew && valid_rm;
    }

    uint8_t illegal_fp_vd_unmasked(uint8_t SEW, uint8_t rm){
        return ! (valid_vtype()) || ! (valid_fp_op(SEW, rm));
    }

    uint8_t illegal_fp_normal(uint8_t vd, uint8_t vm, uint8_t SEW, uint8_t rm){
        return ! (valid_vtype()) || ! (valid_rd_mask(vd, vm)) || ! (valid_fp_op(SEW, rm));
    }

    uint8_t valid_sew_lmul(){
        return get_sew_pow() <= (uint16_t)(get_pow(traits::ELEN)) + (int16_t)(get_lmul_pow());
    }

    uint16_t calculate_new_vl(uint32_t avl, uint16_t vlmax){
        if(avl <= vlmax) {
            return ((uint16_t)avl);
        }
        else {
            if(avl < ((uint32_t)(2) * (uint32_t)(vlmax))) {
                return vlmax;
            }
            else {
                return vlmax;
            }
        }
    }

    void handle_illegal_vtype(){
        auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+::iss::arch::traits<ARCH>::reg_byte_offsets[::iss::arch::traits<ARCH>::vtype]); 
        auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+::iss::arch::traits<ARCH>::reg_byte_offsets[::iss::arch::traits<ARCH>::vl]); 
        *vtype = (uint32_t)1 << ((uint64_t)(traits::XLEN) - (uint64_t)(1));
        *vl = (uint32_t)0;
    }

    uint8_t convert_width(uint8_t width){
        switch(width){
        case (0): 
            return 1;
        case (5): 
            return 2;
        case (6): 
            return 4;
        case (7): 
            return 8;
        }
        return 0;
    }

    uint8_t illegal_load(uint8_t vd, uint8_t vm, uint8_t nf, uint8_t EEW, int8_t EMUL_pow){
        return ! valid_vtype() || ! valid_rd_mask(vd, vm) || ! valid_eew_emul(EEW, EMUL_pow) || ! valid_segment(nf, EMUL_pow);
    }

    uint8_t illegal_store(uint8_t nf, uint8_t EEW, int8_t EMUL_pow){
        return ! valid_vtype() || ! valid_eew_emul(EEW, EMUL_pow) || ! valid_segment(nf, EMUL_pow);
    }

    uint8_t illegal_indexed_load(uint8_t vd, uint8_t vm, uint8_t nf, uint8_t EEW_index, int8_t EMUL_pow_index, int8_t EMUL_pow_data){
        return ! valid_vtype() || ! valid_rd_mask(vd, vm) || ! valid_eew_emul(EEW_index, EMUL_pow_index) || ! valid_segment(nf, EMUL_pow_data);
    }

    uint8_t illegal_indexed_store(uint8_t nf, uint8_t EEW_index, int8_t EMUL_pow_index, int8_t EMUL_pow_data){
        return ! valid_vtype() || ! valid_eew_emul(EEW_index, EMUL_pow_index) || ! valid_segment(nf, EMUL_pow_data);
    }

    uint8_t illegal_reduction(){
        auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+::iss::arch::traits<ARCH>::reg_byte_offsets[::iss::arch::traits<ARCH>::vstart]); 
        return ! valid_vtype() || *vstart != 0;
    }

    uint8_t illegal_reduction_widen(uint8_t EEW){
        return illegal_reduction() || ! (EEW >= 8 && EEW <= traits::ELEN);
    }

    uint8_t illegal_fp_reduction(uint8_t SEW, uint8_t rm){
        auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+::iss::arch::traits<ARCH>::reg_byte_offsets[::iss::arch::traits<ARCH>::vstart]); 
        return ! valid_vtype() || *vstart != 0 || ! valid_fp_op(SEW, rm);
    }

    uint8_t illegal_fp_reduction_widen(uint8_t SEW, uint8_t rm, uint8_t EEW){
        return illegal_fp_reduction(SEW, rm) || ! (EEW >= 8 && EEW <= traits::ELEN);
    }

    uint8_t illegal_fp_variable_width(uint8_t vd, uint8_t vm, uint8_t SEW, uint8_t rm, uint8_t SEW_new, int8_t LMUL_pow_new){
        return ! (valid_vtype()) || ! (valid_rd_mask(vd, vm)) || ! (valid_fp_op(SEW, rm)) || ! (valid_eew_emul(SEW_new, LMUL_pow_new));
    }

    uint8_t illegal_fp_vd_masked(uint8_t vd, uint8_t SEW, uint8_t rm){
        return ! (valid_vtype()) || vd == 0 || ! (valid_fp_op(SEW, rm));
    }


private:
    /****************************************************************************
     * start opcode definitions
     ****************************************************************************/
    struct instruction_descriptor {
        uint32_t length;
        uint32_t value;
        uint32_t mask;
        typename arch::traits<ARCH>::opcode_e op;
    };

    const std::array<instruction_descriptor, 787> instr_descr = {{
         /* entries are: size, valid value, valid mask, function ptr */
        {32, 0b00000000000000000000000000110111, 0b00000000000000000000000001111111, arch::traits<ARCH>::opcode_e::LUI},
        {32, 0b00000000000000000000000000010111, 0b00000000000000000000000001111111, arch::traits<ARCH>::opcode_e::AUIPC},
        {32, 0b00000000000000000000000001101111, 0b00000000000000000000000001111111, arch::traits<ARCH>::opcode_e::JAL},
        {32, 0b00000000000000000000000001100111, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::JALR},
        {32, 0b00000000000000000000000001100011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::BEQ},
        {32, 0b00000000000000000001000001100011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::BNE},
        {32, 0b00000000000000000100000001100011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::BLT},
        {32, 0b00000000000000000101000001100011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::BGE},
        {32, 0b00000000000000000110000001100011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::BLTU},
        {32, 0b00000000000000000111000001100011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::BGEU},
        {32, 0b00000000000000000000000000000011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::LB},
        {32, 0b00000000000000000001000000000011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::LH},
        {32, 0b00000000000000000010000000000011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::LW},
        {32, 0b00000000000000000100000000000011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::LBU},
        {32, 0b00000000000000000101000000000011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::LHU},
        {32, 0b00000000000000000000000000100011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::SB},
        {32, 0b00000000000000000001000000100011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::SH},
        {32, 0b00000000000000000010000000100011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::SW},
        {32, 0b00000000000000000000000000010011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::ADDI},
        {32, 0b00000000000000000010000000010011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::SLTI},
        {32, 0b00000000000000000011000000010011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::SLTIU},
        {32, 0b00000000000000000100000000010011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::XORI},
        {32, 0b00000000000000000110000000010011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::ORI},
        {32, 0b00000000000000000111000000010011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::ANDI},
        {32, 0b00000000000000000001000000010011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::SLLI},
        {32, 0b00000000000000000101000000010011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::SRLI},
        {32, 0b01000000000000000101000000010011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::SRAI},
        {32, 0b00000000000000000000000000110011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::ADD},
        {32, 0b01000000000000000000000000110011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::SUB},
        {32, 0b00000000000000000001000000110011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::SLL},
        {32, 0b00000000000000000010000000110011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::SLT},
        {32, 0b00000000000000000011000000110011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::SLTU},
        {32, 0b00000000000000000100000000110011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::XOR},
        {32, 0b00000000000000000101000000110011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::SRL},
        {32, 0b01000000000000000101000000110011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::SRA},
        {32, 0b00000000000000000110000000110011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::OR},
        {32, 0b00000000000000000111000000110011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::AND},
        {32, 0b00000000000000000000000000001111, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::FENCE},
        {32, 0b00000000000000000000000001110011, 0b11111111111111111111111111111111, arch::traits<ARCH>::opcode_e::ECALL},
        {32, 0b00000000000100000000000001110011, 0b11111111111111111111111111111111, arch::traits<ARCH>::opcode_e::EBREAK},
        {32, 0b00110000001000000000000001110011, 0b11111111111111111111111111111111, arch::traits<ARCH>::opcode_e::MRET},
        {32, 0b00010000010100000000000001110011, 0b11111111111111111111111111111111, arch::traits<ARCH>::opcode_e::WFI},
        {32, 0b00000000000000000001000001110011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::CSRRW},
        {32, 0b00000000000000000010000001110011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::CSRRS},
        {32, 0b00000000000000000011000001110011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::CSRRC},
        {32, 0b00000000000000000101000001110011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::CSRRWI},
        {32, 0b00000000000000000110000001110011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::CSRRSI},
        {32, 0b00000000000000000111000001110011, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::CSRRCI},
        {32, 0b00000000000000000001000000001111, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::FENCE_I},
        {32, 0b00000010000000000000000000110011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::MUL},
        {32, 0b00000010000000000001000000110011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::MULH},
        {32, 0b00000010000000000010000000110011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::MULHSU},
        {32, 0b00000010000000000011000000110011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::MULHU},
        {32, 0b00000010000000000100000000110011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::DIV},
        {32, 0b00000010000000000101000000110011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::DIVU},
        {32, 0b00000010000000000110000000110011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::REM},
        {32, 0b00000010000000000111000000110011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::REMU},
        {32, 0b00010000000000000010000000101111, 0b11111001111100000111000001111111, arch::traits<ARCH>::opcode_e::LRW},
        {32, 0b00011000000000000010000000101111, 0b11111000000000000111000001111111, arch::traits<ARCH>::opcode_e::SCW},
        {32, 0b00001000000000000010000000101111, 0b11111000000000000111000001111111, arch::traits<ARCH>::opcode_e::AMOSWAPW},
        {32, 0b00000000000000000010000000101111, 0b11111000000000000111000001111111, arch::traits<ARCH>::opcode_e::AMOADDW},
        {32, 0b00100000000000000010000000101111, 0b11111000000000000111000001111111, arch::traits<ARCH>::opcode_e::AMOXORW},
        {32, 0b01100000000000000010000000101111, 0b11111000000000000111000001111111, arch::traits<ARCH>::opcode_e::AMOANDW},
        {32, 0b01000000000000000010000000101111, 0b11111000000000000111000001111111, arch::traits<ARCH>::opcode_e::AMOORW},
        {32, 0b10000000000000000010000000101111, 0b11111000000000000111000001111111, arch::traits<ARCH>::opcode_e::AMOMINW},
        {32, 0b10100000000000000010000000101111, 0b11111000000000000111000001111111, arch::traits<ARCH>::opcode_e::AMOMAXW},
        {32, 0b11000000000000000010000000101111, 0b11111000000000000111000001111111, arch::traits<ARCH>::opcode_e::AMOMINUW},
        {32, 0b11100000000000000010000000101111, 0b11111000000000000111000001111111, arch::traits<ARCH>::opcode_e::AMOMAXUW},
        {16, 0b0000000000000000, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__ADDI4SPN},
        {16, 0b0100000000000000, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__LW},
        {16, 0b1100000000000000, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__SW},
        {16, 0b0000000000000001, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__ADDI},
        {16, 0b0000000000000001, 0b1110111110000011, arch::traits<ARCH>::opcode_e::C__NOP},
        {16, 0b0010000000000001, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__JAL},
        {16, 0b0100000000000001, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__LI},
        {16, 0b0110000000000001, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__LUI},
        {16, 0b0110000100000001, 0b1110111110000011, arch::traits<ARCH>::opcode_e::C__ADDI16SP},
        {16, 0b0110000000000001, 0b1111000001111111, arch::traits<ARCH>::opcode_e::__reserved_clui},
        {16, 0b1000000000000001, 0b1111110000000011, arch::traits<ARCH>::opcode_e::C__SRLI},
        {16, 0b1000010000000001, 0b1111110000000011, arch::traits<ARCH>::opcode_e::C__SRAI},
        {16, 0b1000100000000001, 0b1110110000000011, arch::traits<ARCH>::opcode_e::C__ANDI},
        {16, 0b1000110000000001, 0b1111110001100011, arch::traits<ARCH>::opcode_e::C__SUB},
        {16, 0b1000110000100001, 0b1111110001100011, arch::traits<ARCH>::opcode_e::C__XOR},
        {16, 0b1000110001000001, 0b1111110001100011, arch::traits<ARCH>::opcode_e::C__OR},
        {16, 0b1000110001100001, 0b1111110001100011, arch::traits<ARCH>::opcode_e::C__AND},
        {16, 0b1010000000000001, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__J},
        {16, 0b1100000000000001, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__BEQZ},
        {16, 0b1110000000000001, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__BNEZ},
        {16, 0b0000000000000010, 0b1111000000000011, arch::traits<ARCH>::opcode_e::C__SLLI},
        {16, 0b0100000000000010, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__LWSP},
        {16, 0b1000000000000010, 0b1111000000000011, arch::traits<ARCH>::opcode_e::C__MV},
        {16, 0b1000000000000010, 0b1111000001111111, arch::traits<ARCH>::opcode_e::C__JR},
        {16, 0b1000000000000010, 0b1111111111111111, arch::traits<ARCH>::opcode_e::__reserved_cmv},
        {16, 0b1001000000000010, 0b1111000000000011, arch::traits<ARCH>::opcode_e::C__ADD},
        {16, 0b1001000000000010, 0b1111000001111111, arch::traits<ARCH>::opcode_e::C__JALR},
        {16, 0b1001000000000010, 0b1111111111111111, arch::traits<ARCH>::opcode_e::C__EBREAK},
        {16, 0b1100000000000010, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__SWSP},
        {16, 0b0000000000000000, 0b1111111111111111, arch::traits<ARCH>::opcode_e::DII},
        {32, 0b00000000000000000010000000000111, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::FLW},
        {32, 0b00000000000000000010000000100111, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::FSW},
        {32, 0b00000000000000000000000001010011, 0b11111110000000000000000001111111, arch::traits<ARCH>::opcode_e::FADD__S},
        {32, 0b00001000000000000000000001010011, 0b11111110000000000000000001111111, arch::traits<ARCH>::opcode_e::FSUB__S},
        {32, 0b00010000000000000000000001010011, 0b11111110000000000000000001111111, arch::traits<ARCH>::opcode_e::FMUL__S},
        {32, 0b00011000000000000000000001010011, 0b11111110000000000000000001111111, arch::traits<ARCH>::opcode_e::FDIV__S},
        {32, 0b00101000000000000000000001010011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::FMIN__S},
        {32, 0b00101000000000000001000001010011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::FMAX__S},
        {32, 0b01011000000000000000000001010011, 0b11111111111100000000000001111111, arch::traits<ARCH>::opcode_e::FSQRT__S},
        {32, 0b00000000000000000000000001000011, 0b00000110000000000000000001111111, arch::traits<ARCH>::opcode_e::FMADD__S},
        {32, 0b00000000000000000000000001000111, 0b00000110000000000000000001111111, arch::traits<ARCH>::opcode_e::FMSUB__S},
        {32, 0b00000000000000000000000001001111, 0b00000110000000000000000001111111, arch::traits<ARCH>::opcode_e::FNMADD__S},
        {32, 0b00000000000000000000000001001011, 0b00000110000000000000000001111111, arch::traits<ARCH>::opcode_e::FNMSUB__S},
        {32, 0b11000000000000000000000001010011, 0b11111111111100000000000001111111, arch::traits<ARCH>::opcode_e::FCVT__W__S},
        {32, 0b11000000000100000000000001010011, 0b11111111111100000000000001111111, arch::traits<ARCH>::opcode_e::FCVT__WU__S},
        {32, 0b11010000000000000000000001010011, 0b11111111111100000000000001111111, arch::traits<ARCH>::opcode_e::FCVT__S__W},
        {32, 0b11010000000100000000000001010011, 0b11111111111100000000000001111111, arch::traits<ARCH>::opcode_e::FCVT__S__WU},
        {32, 0b00100000000000000000000001010011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::FSGNJ__S},
        {32, 0b00100000000000000001000001010011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::FSGNJN__S},
        {32, 0b00100000000000000010000001010011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::FSGNJX__S},
        {32, 0b11100000000000000000000001010011, 0b11111111111100000111000001111111, arch::traits<ARCH>::opcode_e::FMV__X__W},
        {32, 0b11110000000000000000000001010011, 0b11111111111100000111000001111111, arch::traits<ARCH>::opcode_e::FMV__W__X},
        {32, 0b10100000000000000010000001010011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::FEQ__S},
        {32, 0b10100000000000000001000001010011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::FLT__S},
        {32, 0b10100000000000000000000001010011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::FLE__S},
        {32, 0b11100000000000000001000001010011, 0b11111111111100000111000001111111, arch::traits<ARCH>::opcode_e::FCLASS__S},
        {16, 0b0110000000000000, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__FLW},
        {16, 0b1110000000000000, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__FSW},
        {16, 0b0110000000000010, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__FLWSP},
        {16, 0b1110000000000010, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__FSWSP},
        {32, 0b00000000000000000011000000000111, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::FLD},
        {32, 0b00000000000000000011000000100111, 0b00000000000000000111000001111111, arch::traits<ARCH>::opcode_e::FSD},
        {32, 0b00000010000000000000000001010011, 0b11111110000000000000000001111111, arch::traits<ARCH>::opcode_e::FADD__D},
        {32, 0b00001010000000000000000001010011, 0b11111110000000000000000001111111, arch::traits<ARCH>::opcode_e::FSUB__D},
        {32, 0b00010010000000000000000001010011, 0b11111110000000000000000001111111, arch::traits<ARCH>::opcode_e::FMUL__D},
        {32, 0b00011010000000000000000001010011, 0b11111110000000000000000001111111, arch::traits<ARCH>::opcode_e::FDIV__D},
        {32, 0b00101010000000000000000001010011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::FMIN__D},
        {32, 0b00101010000000000001000001010011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::FMAX__D},
        {32, 0b01011010000000000000000001010011, 0b11111111111100000000000001111111, arch::traits<ARCH>::opcode_e::FSQRT__D},
        {32, 0b00000010000000000000000001000011, 0b00000110000000000000000001111111, arch::traits<ARCH>::opcode_e::FMADD__D},
        {32, 0b00000010000000000000000001000111, 0b00000110000000000000000001111111, arch::traits<ARCH>::opcode_e::FMSUB__D},
        {32, 0b00000010000000000000000001001111, 0b00000110000000000000000001111111, arch::traits<ARCH>::opcode_e::FNMADD__D},
        {32, 0b00000010000000000000000001001011, 0b00000110000000000000000001111111, arch::traits<ARCH>::opcode_e::FNMSUB__D},
        {32, 0b11000010000000000000000001010011, 0b11111111111100000000000001111111, arch::traits<ARCH>::opcode_e::FCVT__W__D},
        {32, 0b11000010000100000000000001010011, 0b11111111111100000000000001111111, arch::traits<ARCH>::opcode_e::FCVT__WU__D},
        {32, 0b11010010000000000000000001010011, 0b11111111111100000000000001111111, arch::traits<ARCH>::opcode_e::FCVT__D__W},
        {32, 0b11010010000100000000000001010011, 0b11111111111100000000000001111111, arch::traits<ARCH>::opcode_e::FCVT__D__WU},
        {32, 0b01000000000100000000000001010011, 0b11111111111100000000000001111111, arch::traits<ARCH>::opcode_e::FCVT__S__D},
        {32, 0b01000010000000000000000001010011, 0b11111111111100000000000001111111, arch::traits<ARCH>::opcode_e::FCVT__D__S},
        {32, 0b00100010000000000000000001010011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::FSGNJ__D},
        {32, 0b00100010000000000001000001010011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::FSGNJN__D},
        {32, 0b00100010000000000010000001010011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::FSGNJX__D},
        {32, 0b10100010000000000010000001010011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::FEQ__D},
        {32, 0b10100010000000000001000001010011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::FLT__D},
        {32, 0b10100010000000000000000001010011, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::FLE__D},
        {32, 0b11100010000000000001000001010011, 0b11111111111100000111000001111111, arch::traits<ARCH>::opcode_e::FCLASS__D},
        {16, 0b0010000000000000, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__FLD},
        {16, 0b1010000000000000, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__FSD},
        {16, 0b0010000000000010, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__FLDSP},
        {16, 0b1010000000000010, 0b1110000000000011, arch::traits<ARCH>::opcode_e::C__FSDSP},
        {32, 0b00010010000000000000000001110011, 0b11111110000000000111111111111111, arch::traits<ARCH>::opcode_e::SFENCE__VMA},
        {32, 0b00010000001000000000000001110011, 0b11111111111111111111111111111111, arch::traits<ARCH>::opcode_e::SRET},
        {32, 0b00000000000000000111000001010111, 0b11110000000000000111000001111111, arch::traits<ARCH>::opcode_e::VSETVLI},
        {32, 0b11000000000000000111000001010111, 0b11110000000000000111000001111111, arch::traits<ARCH>::opcode_e::VSETIVLI},
        {32, 0b10000000000000000111000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VSETVL},
        {32, 0b00000000000000000000000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLE8__V},
        {32, 0b00000000000000000101000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLE16__V},
        {32, 0b00000000000000000110000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLE32__V},
        {32, 0b00000000000000000111000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLE64__V},
        {32, 0b00100000000000000000000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG2E8__V},
        {32, 0b00100000000000000101000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG2E16__V},
        {32, 0b00100000000000000110000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG2E32__V},
        {32, 0b00100000000000000111000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG2E64__V},
        {32, 0b01000000000000000000000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG3E8__V},
        {32, 0b01000000000000000101000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG3E16__V},
        {32, 0b01000000000000000110000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG3E32__V},
        {32, 0b01000000000000000111000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG3E64__V},
        {32, 0b01100000000000000000000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG4E8__V},
        {32, 0b01100000000000000101000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG4E16__V},
        {32, 0b01100000000000000110000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG4E32__V},
        {32, 0b01100000000000000111000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG4E64__V},
        {32, 0b10000000000000000000000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG5E8__V},
        {32, 0b10000000000000000101000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG5E16__V},
        {32, 0b10000000000000000110000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG5E32__V},
        {32, 0b10000000000000000111000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG5E64__V},
        {32, 0b10100000000000000000000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG6E8__V},
        {32, 0b10100000000000000101000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG6E16__V},
        {32, 0b10100000000000000110000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG6E32__V},
        {32, 0b10100000000000000111000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG6E64__V},
        {32, 0b11000000000000000000000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG7E8__V},
        {32, 0b11000000000000000101000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG7E16__V},
        {32, 0b11000000000000000110000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG7E32__V},
        {32, 0b11000000000000000111000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG7E64__V},
        {32, 0b11100000000000000000000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG8E8__V},
        {32, 0b11100000000000000101000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG8E16__V},
        {32, 0b11100000000000000110000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG8E32__V},
        {32, 0b11100000000000000111000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG8E64__V},
        {32, 0b00000000000000000000000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSE8__V},
        {32, 0b00000000000000000101000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSE16__V},
        {32, 0b00000000000000000110000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSE32__V},
        {32, 0b00000000000000000111000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSE64__V},
        {32, 0b00100000000000000000000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG2E8__V},
        {32, 0b00100000000000000101000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG2E16__V},
        {32, 0b00100000000000000110000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG2E32__V},
        {32, 0b00100000000000000111000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG2E64__V},
        {32, 0b01000000000000000000000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG3E8__V},
        {32, 0b01000000000000000101000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG3E16__V},
        {32, 0b01000000000000000110000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG3E32__V},
        {32, 0b01000000000000000111000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG3E64__V},
        {32, 0b01100000000000000000000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG4E8__V},
        {32, 0b01100000000000000101000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG4E16__V},
        {32, 0b01100000000000000110000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG4E32__V},
        {32, 0b01100000000000000111000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG4E64__V},
        {32, 0b10000000000000000000000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG5E8__V},
        {32, 0b10000000000000000101000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG5E16__V},
        {32, 0b10000000000000000110000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG5E32__V},
        {32, 0b10000000000000000111000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG5E64__V},
        {32, 0b10100000000000000000000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG6E8__V},
        {32, 0b10100000000000000101000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG6E16__V},
        {32, 0b10100000000000000110000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG6E32__V},
        {32, 0b10100000000000000111000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG6E64__V},
        {32, 0b11000000000000000000000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG7E8__V},
        {32, 0b11000000000000000101000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG7E16__V},
        {32, 0b11000000000000000110000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG7E32__V},
        {32, 0b11000000000000000111000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG7E64__V},
        {32, 0b11100000000000000000000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG8E8__V},
        {32, 0b11100000000000000101000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG8E16__V},
        {32, 0b11100000000000000110000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG8E32__V},
        {32, 0b11100000000000000111000000100111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VSSEG8E64__V},
        {32, 0b00001000000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSE8__V},
        {32, 0b00001000000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSE16__V},
        {32, 0b00001000000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSE32__V},
        {32, 0b00001000000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSE64__V},
        {32, 0b00101000000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG2E8__V},
        {32, 0b00101000000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG2E16__V},
        {32, 0b00101000000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG2E32__V},
        {32, 0b00101000000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG2E64__V},
        {32, 0b01001000000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG3E8__V},
        {32, 0b01001000000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG3E16__V},
        {32, 0b01001000000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG3E32__V},
        {32, 0b01001000000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG3E64__V},
        {32, 0b01101000000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG4E8__V},
        {32, 0b01101000000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG4E16__V},
        {32, 0b01101000000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG4E32__V},
        {32, 0b01101000000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG4E64__V},
        {32, 0b10001000000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG5E8__V},
        {32, 0b10001000000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG5E16__V},
        {32, 0b10001000000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG5E32__V},
        {32, 0b10001000000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG5E64__V},
        {32, 0b10101000000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG6E8__V},
        {32, 0b10101000000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG6E16__V},
        {32, 0b10101000000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG6E32__V},
        {32, 0b10101000000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG6E64__V},
        {32, 0b11001000000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG7E8__V},
        {32, 0b11001000000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG7E16__V},
        {32, 0b11001000000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG7E32__V},
        {32, 0b11001000000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG7E64__V},
        {32, 0b11101000000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG8E8__V},
        {32, 0b11101000000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG8E16__V},
        {32, 0b11101000000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG8E32__V},
        {32, 0b11101000000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLSSEG8E64__V},
        {32, 0b00001000000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSE8__V},
        {32, 0b00001000000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSE16__V},
        {32, 0b00001000000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSE32__V},
        {32, 0b00001000000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSE64__V},
        {32, 0b00101000000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG2E8__V},
        {32, 0b00101000000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG2E16__V},
        {32, 0b00101000000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG2E32__V},
        {32, 0b00101000000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG2E64__V},
        {32, 0b01001000000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG3E8__V},
        {32, 0b01001000000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG3E16__V},
        {32, 0b01001000000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG3E32__V},
        {32, 0b01001000000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG3E64__V},
        {32, 0b01101000000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG4E8__V},
        {32, 0b01101000000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG4E16__V},
        {32, 0b01101000000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG4E32__V},
        {32, 0b01101000000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG4E64__V},
        {32, 0b10001000000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG5E8__V},
        {32, 0b10001000000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG5E16__V},
        {32, 0b10001000000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG5E32__V},
        {32, 0b10001000000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG5E64__V},
        {32, 0b10101000000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG6E8__V},
        {32, 0b10101000000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG6E16__V},
        {32, 0b10101000000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG6E32__V},
        {32, 0b10101000000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG6E64__V},
        {32, 0b11001000000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG7E8__V},
        {32, 0b11001000000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG7E16__V},
        {32, 0b11001000000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG7E32__V},
        {32, 0b11001000000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG7E64__V},
        {32, 0b11101000000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG8E8__V},
        {32, 0b11101000000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG8E16__V},
        {32, 0b11101000000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG8E32__V},
        {32, 0b11101000000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSSEG8E64__V},
        {32, 0b00000001000000000000000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLE8FF__V},
        {32, 0b00000001000000000101000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLE16FF__V},
        {32, 0b00000001000000000110000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLE32FF__V},
        {32, 0b00000001000000000111000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLE64FF__V},
        {32, 0b00100001000000000000000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG2E8FF__V},
        {32, 0b00100001000000000101000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG2E16FF__V},
        {32, 0b00100001000000000110000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG2E32FF__V},
        {32, 0b00100001000000000111000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG2E64FF__V},
        {32, 0b01000001000000000000000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG3E8FF__V},
        {32, 0b01000001000000000101000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG3E16FF__V},
        {32, 0b01000001000000000110000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG3E32FF__V},
        {32, 0b01000001000000000111000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG3E64FF__V},
        {32, 0b01100001000000000000000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG4E8FF__V},
        {32, 0b01100001000000000101000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG4E16FF__V},
        {32, 0b01100001000000000110000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG4E32FF__V},
        {32, 0b01100001000000000111000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG4E64FF__V},
        {32, 0b10000001000000000000000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG5E8FF__V},
        {32, 0b10000001000000000101000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG5E16FF__V},
        {32, 0b10000001000000000110000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG5E32FF__V},
        {32, 0b10000001000000000111000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG5E64FF__V},
        {32, 0b10100001000000000000000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG6E8FF__V},
        {32, 0b10100001000000000101000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG6E16FF__V},
        {32, 0b10100001000000000110000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG6E32FF__V},
        {32, 0b10100001000000000111000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG6E64FF__V},
        {32, 0b11000001000000000000000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG7E8FF__V},
        {32, 0b11000001000000000101000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG7E16FF__V},
        {32, 0b11000001000000000110000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG7E32FF__V},
        {32, 0b11000001000000000111000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG7E64FF__V},
        {32, 0b11100001000000000000000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG8E8FF__V},
        {32, 0b11100001000000000101000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG8E16FF__V},
        {32, 0b11100001000000000110000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG8E32FF__V},
        {32, 0b11100001000000000111000000000111, 0b11101101111100000111000001111111, arch::traits<ARCH>::opcode_e::VLSEG8E64FF__V},
        {32, 0b00000010101100000000000000100111, 0b11111111111100000111000001111111, arch::traits<ARCH>::opcode_e::VSM__V},
        {32, 0b00000010101100000000000000000111, 0b11111111111100000111000001111111, arch::traits<ARCH>::opcode_e::VLM__V},
        {32, 0b00000010100000000000000000000111, 0b11101111111100000111000001111111, arch::traits<ARCH>::opcode_e::VL1RE8__V},
        {32, 0b00000010100000000101000000000111, 0b11101111111100000111000001111111, arch::traits<ARCH>::opcode_e::VL1RE16__V},
        {32, 0b00000010100000000110000000000111, 0b11101111111100000111000001111111, arch::traits<ARCH>::opcode_e::VL1RE32__V},
        {32, 0b00000010100000000111000000000111, 0b11101111111100000111000001111111, arch::traits<ARCH>::opcode_e::VL1RE64__V},
        {32, 0b00100010100000000000000000000111, 0b11101111111100000111000001111111, arch::traits<ARCH>::opcode_e::VL2RE8__V},
        {32, 0b00100010100000000101000000000111, 0b11101111111100000111000001111111, arch::traits<ARCH>::opcode_e::VL2RE16__V},
        {32, 0b00100010100000000110000000000111, 0b11101111111100000111000001111111, arch::traits<ARCH>::opcode_e::VL2RE32__V},
        {32, 0b00100010100000000111000000000111, 0b11101111111100000111000001111111, arch::traits<ARCH>::opcode_e::VL2RE64__V},
        {32, 0b01100010100000000000000000000111, 0b11101111111100000111000001111111, arch::traits<ARCH>::opcode_e::VL4RE8__V},
        {32, 0b01100010100000000101000000000111, 0b11101111111100000111000001111111, arch::traits<ARCH>::opcode_e::VL4RE16__V},
        {32, 0b01100010100000000110000000000111, 0b11101111111100000111000001111111, arch::traits<ARCH>::opcode_e::VL4RE32__V},
        {32, 0b01100010100000000111000000000111, 0b11101111111100000111000001111111, arch::traits<ARCH>::opcode_e::VL4RE64__V},
        {32, 0b11100010100000000000000000000111, 0b11101111111100000111000001111111, arch::traits<ARCH>::opcode_e::VL8RE8__V},
        {32, 0b11100010100000000101000000000111, 0b11101111111100000111000001111111, arch::traits<ARCH>::opcode_e::VL8RE16__V},
        {32, 0b11100010100000000110000000000111, 0b11101111111100000111000001111111, arch::traits<ARCH>::opcode_e::VL8RE32__V},
        {32, 0b11100010100000000111000000000111, 0b11101111111100000111000001111111, arch::traits<ARCH>::opcode_e::VL8RE64__V},
        {32, 0b00000010100000000000000000100111, 0b11111111111100000111000001111111, arch::traits<ARCH>::opcode_e::VS1RE64__V},
        {32, 0b00100010100000000000000000100111, 0b11111111111100000111000001111111, arch::traits<ARCH>::opcode_e::VS2RE64__V},
        {32, 0b01100010100000000000000000100111, 0b11111111111100000111000001111111, arch::traits<ARCH>::opcode_e::VS4RE64__V},
        {32, 0b11100010100000000000000000100111, 0b11111111111100000111000001111111, arch::traits<ARCH>::opcode_e::VS8RE64__V},
        {32, 0b00001100000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXEI8__V},
        {32, 0b00001100000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXEI16__V},
        {32, 0b00001100000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXEI32__V},
        {32, 0b00001100000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXEI64__V},
        {32, 0b00101100000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG2EI8__V},
        {32, 0b00101100000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG2EI16__V},
        {32, 0b00101100000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG2EI32__V},
        {32, 0b00101100000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG2EI64__V},
        {32, 0b01001100000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG3EI8__V},
        {32, 0b01001100000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG3EI16__V},
        {32, 0b01001100000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG3EI32__V},
        {32, 0b01001100000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG3EI64__V},
        {32, 0b01101100000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG4EI8__V},
        {32, 0b01101100000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG4EI16__V},
        {32, 0b01101100000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG4EI32__V},
        {32, 0b01101100000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG4EI64__V},
        {32, 0b10001100000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG5EI8__V},
        {32, 0b10001100000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG5EI16__V},
        {32, 0b10001100000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG5EI32__V},
        {32, 0b10001100000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG5EI64__V},
        {32, 0b10101100000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG6EI8__V},
        {32, 0b10101100000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG6EI16__V},
        {32, 0b10101100000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG6EI32__V},
        {32, 0b10101100000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG6EI64__V},
        {32, 0b11001100000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG7EI8__V},
        {32, 0b11001100000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG7EI16__V},
        {32, 0b11001100000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG7EI32__V},
        {32, 0b11001100000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG7EI64__V},
        {32, 0b11101100000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG8EI8__V},
        {32, 0b11101100000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG8EI16__V},
        {32, 0b11101100000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG8EI32__V},
        {32, 0b11101100000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLOXSEG8EI64__V},
        {32, 0b00001100000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXEI8__V},
        {32, 0b00001100000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXEI16__V},
        {32, 0b00001100000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXEI32__V},
        {32, 0b00001100000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXEI64__V},
        {32, 0b00101100000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG2EI8__V},
        {32, 0b00101100000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG2EI16__V},
        {32, 0b00101100000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG2EI32__V},
        {32, 0b00101100000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG2EI64__V},
        {32, 0b01001100000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG3EI8__V},
        {32, 0b01001100000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG3EI16__V},
        {32, 0b01001100000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG3EI32__V},
        {32, 0b01001100000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG3EI64__V},
        {32, 0b01101100000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG4EI8__V},
        {32, 0b01101100000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG4EI16__V},
        {32, 0b01101100000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG4EI32__V},
        {32, 0b01101100000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG4EI64__V},
        {32, 0b10001100000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG5EI8__V},
        {32, 0b10001100000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG5EI16__V},
        {32, 0b10001100000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG5EI32__V},
        {32, 0b10001100000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG5EI64__V},
        {32, 0b10101100000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG6EI8__V},
        {32, 0b10101100000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG6EI16__V},
        {32, 0b10101100000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG6EI32__V},
        {32, 0b10101100000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG6EI64__V},
        {32, 0b11001100000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG7EI8__V},
        {32, 0b11001100000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG7EI16__V},
        {32, 0b11001100000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG7EI32__V},
        {32, 0b11001100000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG7EI64__V},
        {32, 0b11101100000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG8EI8__V},
        {32, 0b11101100000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG8EI16__V},
        {32, 0b11101100000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG8EI32__V},
        {32, 0b11101100000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSOXSEG8EI64__V},
        {32, 0b00000100000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXEI8__V},
        {32, 0b00000100000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXEI16__V},
        {32, 0b00000100000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXEI32__V},
        {32, 0b00000100000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXEI64__V},
        {32, 0b00100100000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG2EI8__V},
        {32, 0b00100100000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG2EI16__V},
        {32, 0b00100100000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG2EI32__V},
        {32, 0b00100100000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG2EI64__V},
        {32, 0b01000100000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG3EI8__V},
        {32, 0b01000100000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG3EI16__V},
        {32, 0b01000100000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG3EI32__V},
        {32, 0b01000100000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG3EI64__V},
        {32, 0b01100100000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG4EI8__V},
        {32, 0b01100100000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG4EI16__V},
        {32, 0b01100100000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG4EI32__V},
        {32, 0b01100100000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG4EI64__V},
        {32, 0b10000100000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG5EI8__V},
        {32, 0b10000100000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG5EI16__V},
        {32, 0b10000100000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG5EI32__V},
        {32, 0b10000100000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG5EI64__V},
        {32, 0b10100100000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG6EI8__V},
        {32, 0b10100100000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG6EI16__V},
        {32, 0b10100100000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG6EI32__V},
        {32, 0b10100100000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG6EI64__V},
        {32, 0b11000100000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG7EI8__V},
        {32, 0b11000100000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG7EI16__V},
        {32, 0b11000100000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG7EI32__V},
        {32, 0b11000100000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG7EI64__V},
        {32, 0b11100100000000000000000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG8EI8__V},
        {32, 0b11100100000000000101000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG8EI16__V},
        {32, 0b11100100000000000110000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG8EI32__V},
        {32, 0b11100100000000000111000000000111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VLUXSEG8EI64__V},
        {32, 0b00000100000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXEI8__V},
        {32, 0b00000100000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXEI16__V},
        {32, 0b00000100000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXEI32__V},
        {32, 0b00000100000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXEI64__V},
        {32, 0b00100100000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG2EI8__V},
        {32, 0b00100100000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG2EI16__V},
        {32, 0b00100100000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG2EI32__V},
        {32, 0b00100100000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG2EI64__V},
        {32, 0b01000100000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG3EI8__V},
        {32, 0b01000100000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG3EI16__V},
        {32, 0b01000100000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG3EI32__V},
        {32, 0b01000100000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG3EI64__V},
        {32, 0b01100100000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG4EI8__V},
        {32, 0b01100100000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG4EI16__V},
        {32, 0b01100100000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG4EI32__V},
        {32, 0b01100100000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG4EI64__V},
        {32, 0b10000100000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG5EI8__V},
        {32, 0b10000100000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG5EI16__V},
        {32, 0b10000100000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG5EI32__V},
        {32, 0b10000100000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG5EI64__V},
        {32, 0b10100100000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG6EI8__V},
        {32, 0b10100100000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG6EI16__V},
        {32, 0b10100100000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG6EI32__V},
        {32, 0b10100100000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG6EI64__V},
        {32, 0b11000100000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG7EI8__V},
        {32, 0b11000100000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG7EI16__V},
        {32, 0b11000100000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG7EI32__V},
        {32, 0b11000100000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG7EI64__V},
        {32, 0b11100100000000000000000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG8EI8__V},
        {32, 0b11100100000000000101000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG8EI16__V},
        {32, 0b11100100000000000110000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG8EI32__V},
        {32, 0b11100100000000000111000000100111, 0b11101100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUXSEG8EI64__V},
        {32, 0b00000000000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VADD__VI},
        {32, 0b00000000000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VADD__VV},
        {32, 0b00000000000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VADD__VX},
        {32, 0b00001000000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUB__VV},
        {32, 0b00001000000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSUB__VX},
        {32, 0b00001100000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VRSUB__VI},
        {32, 0b00001100000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VRSUB__VX},
        {32, 0b11000000000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWADDU__VV},
        {32, 0b11000000000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWADDU__VX},
        {32, 0b11001000000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWSUBU__VV},
        {32, 0b11001000000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWSUBU__VX},
        {32, 0b11000100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWADD__VV},
        {32, 0b11000100000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWADD__VX},
        {32, 0b11001100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWSUB__VV},
        {32, 0b11001100000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWSUB__VX},
        {32, 0b11010000000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWADDU__WV},
        {32, 0b11010000000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWADDU__WX},
        {32, 0b11011000000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWSUBU__WV},
        {32, 0b11011000000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWSUBU__WX},
        {32, 0b11010100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWADD__WV},
        {32, 0b11010100000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWADD__WX},
        {32, 0b11011100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWSUB__WV},
        {32, 0b11011100000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWSUB__WX},
        {32, 0b01001000000000110010000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VZEXT__VF2},
        {32, 0b01001000000000111010000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VSEXT__VF2},
        {32, 0b01001000000000100010000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VZEXT__VF4},
        {32, 0b01001000000000101010000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VSEXT__VF4},
        {32, 0b01001000000000010010000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VZEXT__VF8},
        {32, 0b01001000000000011010000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VSEXT__VF8},
        {32, 0b01000000000000000000000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VADC__VVM},
        {32, 0b01000000000000000100000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VADC__VXM},
        {32, 0b01000000000000000011000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VADC__VIM},
        {32, 0b01000100000000000000000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMADC__VVM},
        {32, 0b01000100000000000100000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMADC__VXM},
        {32, 0b01000100000000000011000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMADC__VIM},
        {32, 0b01000110000000000000000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMADC__VV},
        {32, 0b01000110000000000100000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMADC__VX},
        {32, 0b01000110000000000011000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMADC__VI},
        {32, 0b01001000000000000000000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VSBC__VVM},
        {32, 0b01001000000000000100000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VSBC__VXM},
        {32, 0b01001100000000000000000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSBC__VVM},
        {32, 0b01001100000000000100000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSBC__VXM},
        {32, 0b01001110000000000000000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSBC__VV},
        {32, 0b01001110000000000100000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSBC__VX},
        {32, 0b00100100000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VAND__VI},
        {32, 0b00100100000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VAND__VV},
        {32, 0b00100100000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VAND__VX},
        {32, 0b00101000000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VOR__VI},
        {32, 0b00101000000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VOR__VV},
        {32, 0b00101000000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VOR__VX},
        {32, 0b00101100000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VXOR__VI},
        {32, 0b00101100000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VXOR__VV},
        {32, 0b00101100000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VXOR__VX},
        {32, 0b10010100000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSLL__VI},
        {32, 0b10010100000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSLL__VV},
        {32, 0b10010100000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSLL__VX},
        {32, 0b10100000000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSRL__VI},
        {32, 0b10100000000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSRL__VV},
        {32, 0b10100000000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSRL__VX},
        {32, 0b10100100000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSRA__VI},
        {32, 0b10100100000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSRA__VV},
        {32, 0b10100100000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSRA__VX},
        {32, 0b10110000000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VNSRL__WI},
        {32, 0b10110000000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VNSRL__WV},
        {32, 0b10110000000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VNSRL__WX},
        {32, 0b10110100000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VNSRA__WI},
        {32, 0b10110100000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VNSRA__WV},
        {32, 0b10110100000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VNSRA__WX},
        {32, 0b01100000000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSEQ__VI},
        {32, 0b01100000000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSEQ__VV},
        {32, 0b01100000000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSEQ__VX},
        {32, 0b01100100000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSNE__VI},
        {32, 0b01100100000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSNE__VV},
        {32, 0b01100100000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSNE__VX},
        {32, 0b01101000000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSLTU__VV},
        {32, 0b01101000000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSLTU__VX},
        {32, 0b01101100000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSLT__VV},
        {32, 0b01101100000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSLT__VX},
        {32, 0b01110000000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSLEU__VI},
        {32, 0b01110000000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSLEU__VV},
        {32, 0b01110000000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSLEU__VX},
        {32, 0b01110100000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSLE__VI},
        {32, 0b01110100000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSLE__VV},
        {32, 0b01110100000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSLE__VX},
        {32, 0b01111000000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSGTU__VI},
        {32, 0b01111000000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSGTU__VX},
        {32, 0b01111100000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSGT__VI},
        {32, 0b01111100000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMSGT__VX},
        {32, 0b00010000000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMINU__VV},
        {32, 0b00010000000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMINU__VX},
        {32, 0b00010100000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMIN__VV},
        {32, 0b00010100000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMIN__VX},
        {32, 0b00011000000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMAXU__VV},
        {32, 0b00011000000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMAXU__VX},
        {32, 0b00011100000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMAX__VV},
        {32, 0b00011100000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMAX__VX},
        {32, 0b10010100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMUL__VV},
        {32, 0b10010100000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMUL__VX},
        {32, 0b10011100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMULH__VV},
        {32, 0b10011100000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMULH__VX},
        {32, 0b10010000000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMULHU__VV},
        {32, 0b10010000000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMULHU__VX},
        {32, 0b10011000000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMULHSU__VV},
        {32, 0b10011000000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMULHSU__VX},
        {32, 0b10000000000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VDIVU__VV},
        {32, 0b10000000000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VDIVU__VX},
        {32, 0b10000100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VDIV__VV},
        {32, 0b10000100000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VDIV__VX},
        {32, 0b10001000000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VREMU__VV},
        {32, 0b10001000000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VREMU__VX},
        {32, 0b10001100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VREM__VV},
        {32, 0b10001100000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VREM__VX},
        {32, 0b11101100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWMUL__VV},
        {32, 0b11101100000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWMUL__VX},
        {32, 0b11100000000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWMULU__VV},
        {32, 0b11100000000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWMULU__VX},
        {32, 0b11101000000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWMULSU__VV},
        {32, 0b11101000000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWMULSU__VX},
        {32, 0b10110100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMACC__VV},
        {32, 0b10110100000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMACC__VX},
        {32, 0b10111100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VNMSAC__VV},
        {32, 0b10111100000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VNMSAC__VX},
        {32, 0b10100100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMADD__VV},
        {32, 0b10100100000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMADD__VX},
        {32, 0b10101100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VNMSUB__VV},
        {32, 0b10101100000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VNMSUB__VX},
        {32, 0b11110000000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWMACCU__VV},
        {32, 0b11110000000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWMACCU__VX},
        {32, 0b11110100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWMACC__VV},
        {32, 0b11110100000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWMACC__VX},
        {32, 0b11111100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWMACCSU__VV},
        {32, 0b11111100000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWMACCSU__VX},
        {32, 0b11111000000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWMACCUS__VX},
        {32, 0b01011100000000000011000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMERGE__VIM},
        {32, 0b01011100000000000000000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMERGE__VVM},
        {32, 0b01011100000000000100000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMERGE__VXM},
        {32, 0b01011110000000000011000001010111, 0b11111111111100000111000001111111, arch::traits<ARCH>::opcode_e::VMV__V__I},
        {32, 0b01011110000000000000000001010111, 0b11111111111100000111000001111111, arch::traits<ARCH>::opcode_e::VMV__V__V},
        {32, 0b01011110000000000100000001010111, 0b11111111111100000111000001111111, arch::traits<ARCH>::opcode_e::VMV__V__X},
        {32, 0b10000000000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSADDU__VI},
        {32, 0b10000000000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSADDU__VV},
        {32, 0b10000000000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSADDU__VX},
        {32, 0b10000100000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSADD__VI},
        {32, 0b10000100000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSADD__VV},
        {32, 0b10000100000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSADD__VX},
        {32, 0b10001000000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSUBU__VV},
        {32, 0b10001000000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSUBU__VX},
        {32, 0b10001100000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSUB__VV},
        {32, 0b10001100000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSUB__VX},
        {32, 0b00100000000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VAADDU__VV},
        {32, 0b00100000000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VAADDU__VX},
        {32, 0b00100100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VAADD__VV},
        {32, 0b00100100000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VAADD__VX},
        {32, 0b00101000000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VASUBU__VV},
        {32, 0b00101000000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VASUBU__VX},
        {32, 0b00101100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VASUB__VV},
        {32, 0b00101100000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VASUB__VX},
        {32, 0b10011100000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSMUL__VV},
        {32, 0b10011100000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSMUL__VX},
        {32, 0b10101000000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSRL__VI},
        {32, 0b10101000000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSRL__VV},
        {32, 0b10101000000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSRL__VX},
        {32, 0b10101100000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSRA__VI},
        {32, 0b10101100000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSRA__VV},
        {32, 0b10101100000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSSRA__VX},
        {32, 0b10111000000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VNCLIPU__WI},
        {32, 0b10111000000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VNCLIPU__WV},
        {32, 0b10111000000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VNCLIPU__WX},
        {32, 0b10111100000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VNCLIP__WI},
        {32, 0b10111100000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VNCLIP__WV},
        {32, 0b10111100000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VNCLIP__WX},
        {32, 0b00000000000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VREDSUM__VS},
        {32, 0b00011000000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VREDMAXU__VS},
        {32, 0b00011100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VREDMAX__VS},
        {32, 0b00010000000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VREDMINU__VS},
        {32, 0b00010100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VREDMIN__VS},
        {32, 0b00000100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VREDAND__VS},
        {32, 0b00001000000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VREDOR__VS},
        {32, 0b00001100000000000010000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VREDXOR__VS},
        {32, 0b11000000000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWREDSUMU__VS},
        {32, 0b11000100000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VWREDSUM__VS},
        {32, 0b00001100000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFREDOSUM__VS},
        {32, 0b00000100000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFREDUSUM__VS},
        {32, 0b00011100000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFREDMAX__VS},
        {32, 0b00010100000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFREDMIN__VS},
        {32, 0b11001100000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWREDOSUM__VS},
        {32, 0b11000100000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWREDUSUM__VS},
        {32, 0b01100110000000000010000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMAND__MM},
        {32, 0b01110110000000000010000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMNAND__MM},
        {32, 0b01100010000000000010000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMANDN__MM},
        {32, 0b01101110000000000010000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMXOR__MM},
        {32, 0b01101010000000000010000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMOR__MM},
        {32, 0b01111010000000000010000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMNOR__MM},
        {32, 0b01110010000000000010000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMORN__MM},
        {32, 0b01111110000000000010000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VMXNOR__MM},
        {32, 0b01000000000010000010000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VCPOP__M},
        {32, 0b01000000000010001010000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFIRST__M},
        {32, 0b01010000000000001010000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VMSBF__M},
        {32, 0b01010000000000011010000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VMSIF__M},
        {32, 0b01010000000000010010000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VMSOF__M},
        {32, 0b01010000000010000010000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VIOTA__M},
        {32, 0b01010000000010001010000001010111, 0b11111101111111111111000001111111, arch::traits<ARCH>::opcode_e::VID__V},
        {32, 0b01000010000000000110000001010111, 0b11111111111100000111000001111111, arch::traits<ARCH>::opcode_e::VMV__S__X},
        {32, 0b01000010000000000010000001010111, 0b11111110000011111111000001111111, arch::traits<ARCH>::opcode_e::VMV__X__S},
        {32, 0b00111000000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSLIDEUP__VI},
        {32, 0b00111000000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSLIDEUP__VX},
        {32, 0b00111100000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSLIDEDOWN__VI},
        {32, 0b00111100000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSLIDEDOWN__VX},
        {32, 0b00111000000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSLIDE1UP__VX},
        {32, 0b00111100000000000110000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VSLIDE1DOWN__VX},
        {32, 0b00110000000000000011000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VRGATHER__VI},
        {32, 0b00110000000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VRGATHER__VV},
        {32, 0b00110000000000000100000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VRGATHER__VX},
        {32, 0b00111000000000000000000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VRGATHEREI16__VV},
        {32, 0b01011110000000000010000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VCOMPRESS__VM},
        {32, 0b10011110000000000011000001010111, 0b11111110000011111111000001111111, arch::traits<ARCH>::opcode_e::VMV1R__V},
        {32, 0b10011110000000001011000001010111, 0b11111110000011111111000001111111, arch::traits<ARCH>::opcode_e::VMV2R__V},
        {32, 0b10011110000000011011000001010111, 0b11111110000011111111000001111111, arch::traits<ARCH>::opcode_e::VMV4R__V},
        {32, 0b10011110000000111011000001010111, 0b11111110000011111111000001111111, arch::traits<ARCH>::opcode_e::VMV8R__V},
        {32, 0b01000010000000000101000001010111, 0b11111111111100000111000001111111, arch::traits<ARCH>::opcode_e::VFMV__S__F},
        {32, 0b01000010000000000001000001010111, 0b11111110000011111111000001111111, arch::traits<ARCH>::opcode_e::VFMV__F__S},
        {32, 0b00111000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFSLIDE1UP__VF},
        {32, 0b00111100000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFSLIDE1DOWN__VF},
        {32, 0b00000000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFADD__VF},
        {32, 0b00000000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFADD__VV},
        {32, 0b00001000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFSUB__VF},
        {32, 0b00001000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFSUB__VV},
        {32, 0b10011100000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFRSUB__VF},
        {32, 0b11000000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWADD__VF},
        {32, 0b11000000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWADD__VV},
        {32, 0b11001000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWSUB__VF},
        {32, 0b11001000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWSUB__VV},
        {32, 0b11010000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWADD__WF},
        {32, 0b11010000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWADD__WV},
        {32, 0b11011000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWSUB__WF},
        {32, 0b11011000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWSUB__WV},
        {32, 0b10010000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFMUL__VF},
        {32, 0b10010000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFMUL__VV},
        {32, 0b10000000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFDIV__VF},
        {32, 0b10000000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFDIV__VV},
        {32, 0b10000100000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFRDIV__VF},
        {32, 0b11100000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWMUL__VF},
        {32, 0b11100000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWMUL__VV},
        {32, 0b10110000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFMACC__VF},
        {32, 0b10110000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFMACC__VV},
        {32, 0b10110100000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFNMACC__VF},
        {32, 0b10110100000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFNMACC__VV},
        {32, 0b10111000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFMSAC__VF},
        {32, 0b10111000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFMSAC__VV},
        {32, 0b10111100000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFNMSAC__VF},
        {32, 0b10111100000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFNMSAC__VV},
        {32, 0b10100000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFMADD__VF},
        {32, 0b10100000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFMADD__VV},
        {32, 0b10100100000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFNMADD__VF},
        {32, 0b10100100000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFNMADD__VV},
        {32, 0b10101000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFMSUB__VF},
        {32, 0b10101000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFMSUB__VV},
        {32, 0b10101100000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFNMSUB__VF},
        {32, 0b10101100000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFNMSUB__VV},
        {32, 0b11110000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWMACC__VF},
        {32, 0b11110000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWMACC__VV},
        {32, 0b11110100000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWNMACC__VF},
        {32, 0b11110100000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWNMACC__VV},
        {32, 0b11111000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWMSAC__VF},
        {32, 0b11111000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWMSAC__VV},
        {32, 0b11111100000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWNMSAC__VF},
        {32, 0b11111100000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFWNMSAC__VV},
        {32, 0b01001100000000000001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFSQRT__V},
        {32, 0b01001100000000100001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFRSQRT7__V},
        {32, 0b01001100000000101001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFREC7__V},
        {32, 0b00010000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFMIN__VF},
        {32, 0b00010000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFMIN__VV},
        {32, 0b00011000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFMAX__VF},
        {32, 0b00011000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFMAX__VV},
        {32, 0b00100000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFSGNJ__VF},
        {32, 0b00100000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFSGNJ__VV},
        {32, 0b00100100000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFSGNJN__VF},
        {32, 0b00100100000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFSGNJN__VV},
        {32, 0b00101000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFSGNJX__VF},
        {32, 0b00101000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VFSGNJX__VV},
        {32, 0b01100000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMFEQ__VF},
        {32, 0b01100000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMFEQ__VV},
        {32, 0b01110000000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMFNE__VF},
        {32, 0b01110000000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMFNE__VV},
        {32, 0b01101100000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMFLT__VF},
        {32, 0b01101100000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMFLT__VV},
        {32, 0b01100100000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMFLE__VF},
        {32, 0b01100100000000000001000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMFLE__VV},
        {32, 0b01110100000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMFGT__VF},
        {32, 0b01111100000000000101000001010111, 0b11111100000000000111000001111111, arch::traits<ARCH>::opcode_e::VMFGE__VF},
        {32, 0b01001100000010000001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFCLASS__V},
        {32, 0b01011100000000000101000001010111, 0b11111110000000000111000001111111, arch::traits<ARCH>::opcode_e::VFMERGE__VFM},
        {32, 0b01011110000000000101000001010111, 0b11111111111100000111000001111111, arch::traits<ARCH>::opcode_e::VFMV__V__F},
        {32, 0b01001000000000000001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFCVT__XU__F__V},
        {32, 0b01001000000000001001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFCVT__X__F__V},
        {32, 0b01001000000000110001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFCVT__RTZ__XU__F__V},
        {32, 0b01001000000000111001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFCVT__RTZ__X__F__V},
        {32, 0b01001000000000010001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFCVT__F__XU__V},
        {32, 0b01001000000000011001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFCVT__F__X__V},
        {32, 0b01001000000001000001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFWCVT__XU__F__V},
        {32, 0b01001000000001001001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFWCVT__X__F__V},
        {32, 0b01001000000001110001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFWCVT__RTZ__XU__F__V},
        {32, 0b01001000000001111001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFWCVT__RTZ__X__F__V},
        {32, 0b01001000000001010001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFWCVT__F__XU__V},
        {32, 0b01001000000001011001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFWCVT__F__X__V},
        {32, 0b01001000000001100001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFWCVT__F__F__V},
        {32, 0b01001000000010001001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFNCVT__X__F__W},
        {32, 0b01001000000010000001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFNCVT__XU__F__W},
        {32, 0b01001000000010110001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFNCVT__RTZ__XU__F__W},
        {32, 0b01001000000010111001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFNCVT__RTZ__X__F__W},
        {32, 0b01001000000010010001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFNCVT__F__XU__W},
        {32, 0b01001000000010011001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFNCVT__F__X__W},
        {32, 0b01001000000010100001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFNCVT__F__F__W},
        {32, 0b01001000000010101001000001010111, 0b11111100000011111111000001111111, arch::traits<ARCH>::opcode_e::VFNCVT__ROD__F__F__W},
    }};

    //needs to be declared after instr_descr
    decoder instr_decoder;

    iss::status fetch_ins(virt_addr_t pc, uint8_t * data){
        if (this->core.read(iss::address_type::PHYSICAL, pc.access, pc.space, pc.val, 4, data) != iss::Ok)
                    return iss::Err;
        return iss::Ok;
    }
};

template <typename CODE_WORD> void debug_fn(CODE_WORD insn) {
    volatile CODE_WORD x = insn;
    insn = 2 * x;
}
// according to
// https://stackoverflow.com/questions/8871204/count-number-of-1s-in-binary-representation
#ifdef __GCC__
constexpr size_t bit_count(uint32_t u) { return __builtin_popcount(u); }
#elif __cplusplus < 201402L
constexpr size_t uCount(uint32_t u) { return u - ((u >> 1) & 033333333333) - ((u >> 2) & 011111111111); }
constexpr size_t bit_count(uint32_t u) { return ((uCount(u) + (uCount(u) >> 3)) & 030707070707) % 63; }
#else
constexpr size_t bit_count(uint32_t u) {
    size_t uCount = u - ((u >> 1) & 033333333333) - ((u >> 2) & 011111111111);
    return ((uCount + (uCount >> 3)) & 030707070707) % 63;
}
#endif

template <typename ARCH>
vm_impl<ARCH>::vm_impl(ARCH &core, unsigned core_id, unsigned cluster_id)
: vm_base<ARCH>(core, core_id, cluster_id)
, instr_decoder([this]() {
        std::vector<generic_instruction_descriptor> g_instr_descr;
        g_instr_descr.reserve(instr_descr.size());
        for (uint32_t i = 0; i < instr_descr.size(); ++i) {
            generic_instruction_descriptor new_instr_descr {instr_descr[i].value, instr_descr[i].mask, i};
            g_instr_descr.push_back(new_instr_descr);
    }
        return std::move(g_instr_descr);
    }()) {}

inline bool is_icount_limit_enabled(finish_cond_e cond){
    return (cond & finish_cond_e::ICOUNT_LIMIT) == finish_cond_e::ICOUNT_LIMIT;
}

inline bool is_fcount_limit_enabled(finish_cond_e cond){
    return (cond & finish_cond_e::FCOUNT_LIMIT) == finish_cond_e::FCOUNT_LIMIT;
}

inline bool is_jump_to_self_enabled(finish_cond_e cond){
    return (cond & finish_cond_e::JUMP_TO_SELF) == finish_cond_e::JUMP_TO_SELF;
}

template <typename ARCH>
typename vm_base<ARCH>::virt_addr_t vm_impl<ARCH>::execute_inst(finish_cond_e cond, virt_addr_t start, uint64_t count_limit){
    auto pc=start;
    auto* PC = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::PC]);
    auto* NEXT_PC = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::NEXT_PC]);
    auto& trap_state = this->core.reg.trap_state;
    auto& icount =  this->core.reg.icount;
    auto& cycle =  this->core.reg.cycle;
    auto& instret =  this->core.reg.instret;
    auto& instr =  this->core.reg.instruction;
    // we fetch at max 4 byte, alignment is 2
    auto *const data = reinterpret_cast<uint8_t*>(&instr);

    while(!this->core.should_stop() &&
            !(is_icount_limit_enabled(cond) && icount >= count_limit) &&
            !(is_fcount_limit_enabled(cond) && fetch_count >= count_limit)){
        if(this->debugging_enabled())
            this->tgt_adapter->check_continue(*PC);
        pc.val=*PC;
        if(fetch_ins(pc, data)!=iss::Ok){
            if(this->sync_exec && PRE_SYNC) this->do_sync(PRE_SYNC, std::numeric_limits<unsigned>::max());
            process_spawn_blocks();
            if(this->sync_exec && POST_SYNC) this->do_sync(PRE_SYNC, std::numeric_limits<unsigned>::max());
            *PC = super::core.enter_trap(trap_state, pc.val, instr);
        } else {
            if (is_jump_to_self_enabled(cond) &&
                    (instr == 0x0000006f || (instr&0xffff)==0xa001)) throw simulation_stopped(0); // 'J 0' or 'C.J 0'
            uint32_t inst_index = instr_decoder.decode_instr(instr);
            opcode_e inst_id = arch::traits<ARCH>::opcode_e::MAX_OPCODE;;
            if(inst_index <instr_descr.size())
                inst_id = instr_descr[inst_index].op;

            // pre execution stuff
             this->core.reg.last_branch = 0;
            if(this->sync_exec && PRE_SYNC) this->do_sync(PRE_SYNC, static_cast<unsigned>(inst_id));
            try{
                switch(inst_id){
                case arch::traits<ARCH>::opcode_e::LUI: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint32_t imm = ((bit_sub<12,20>(instr) << 12));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {imm:#05x}", fmt::arg("mnemonic", "lui"),
                            fmt::arg("rd", name(rd)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)((int32_t)imm);
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::AUIPC: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint32_t imm = ((bit_sub<12,20>(instr) << 12));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {imm:#08x}", fmt::arg("mnemonic", "auipc"),
                            fmt::arg("rd", name(rd)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)((uint64_t)(*PC) + (int64_t)((int32_t)imm));
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::JAL: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint32_t imm = ((bit_sub<12,8>(instr) << 12) | (bit_sub<20,1>(instr) << 11) | (bit_sub<21,10>(instr) << 1) | (bit_sub<31,1>(instr) << 20));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {imm:#0x}", fmt::arg("mnemonic", "jal"),
                            fmt::arg("rd", name(rd)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t new_pc = (uint32_t)((uint64_t)(*PC) + (int64_t)((int32_t)sext<21>(imm)));
                                        if(new_pc % traits::INSTR_ALIGNMENT) {
                                            set_tval(new_pc);
                                            raise(0, 0);
                                        }
                                        else {
                                            if(rd != 0) {
                                                *(X+rd) = (uint32_t)((uint64_t)(*PC) + (uint64_t)(4));
                                            }
                                            *NEXT_PC = new_pc;
                                            this->core.reg.last_branch = 1;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::JALR: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint16_t imm = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {imm:#0x}", fmt::arg("mnemonic", "jalr"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t addr_mask = (uint32_t)- 2;
                                        uint32_t new_pc = (uint32_t)(((uint64_t)(*(X+rs1)) + (int64_t)((int16_t)sext<12>(imm))) & (uint64_t)(addr_mask));
                                        if(new_pc % traits::INSTR_ALIGNMENT) {
                                            set_tval(new_pc);
                                            raise(0, 0);
                                        }
                                        else {
                                            if(rd != 0) {
                                                *(X+rd) = (uint32_t)((uint64_t)(*PC) + (uint64_t)(4));
                                            }
                                            *NEXT_PC = new_pc;
                                            this->core.reg.last_branch = 1;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::BEQ: {
                    uint16_t imm = ((bit_sub<7,1>(instr) << 11) | (bit_sub<8,4>(instr) << 1) | (bit_sub<25,6>(instr) << 5) | (bit_sub<31,1>(instr) << 12));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs1}, {rs2}, {imm:#0x}", fmt::arg("mnemonic", "beq"),
                            fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs2 >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*(X+rs1) == *(X+rs2)) {
                                            uint32_t new_pc = (uint32_t)((uint64_t)(*PC) + (int64_t)((int16_t)sext<13>(imm)));
                                            if(new_pc % traits::INSTR_ALIGNMENT) {
                                                set_tval(new_pc);
                                                raise(0, 0);
                                            }
                                            else {
                                                *NEXT_PC = new_pc;
                                                this->core.reg.last_branch = 1;
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::BNE: {
                    uint16_t imm = ((bit_sub<7,1>(instr) << 11) | (bit_sub<8,4>(instr) << 1) | (bit_sub<25,6>(instr) << 5) | (bit_sub<31,1>(instr) << 12));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs1}, {rs2}, {imm:#0x}", fmt::arg("mnemonic", "bne"),
                            fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs2 >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*(X+rs1) != *(X+rs2)) {
                                            uint32_t new_pc = (uint32_t)((uint64_t)(*PC) + (int64_t)((int16_t)sext<13>(imm)));
                                            if(new_pc % traits::INSTR_ALIGNMENT) {
                                                set_tval(new_pc);
                                                raise(0, 0);
                                            }
                                            else {
                                                *NEXT_PC = new_pc;
                                                this->core.reg.last_branch = 1;
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::BLT: {
                    uint16_t imm = ((bit_sub<7,1>(instr) << 11) | (bit_sub<8,4>(instr) << 1) | (bit_sub<25,6>(instr) << 5) | (bit_sub<31,1>(instr) << 12));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs1}, {rs2}, {imm:#0x}", fmt::arg("mnemonic", "blt"),
                            fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs2 >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if((int32_t)*(X+rs1) < (int32_t)*(X+rs2)) {
                                            uint32_t new_pc = (uint32_t)((uint64_t)(*PC) + (int64_t)((int16_t)sext<13>(imm)));
                                            if(new_pc % traits::INSTR_ALIGNMENT) {
                                                set_tval(new_pc);
                                                raise(0, 0);
                                            }
                                            else {
                                                *NEXT_PC = new_pc;
                                                this->core.reg.last_branch = 1;
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::BGE: {
                    uint16_t imm = ((bit_sub<7,1>(instr) << 11) | (bit_sub<8,4>(instr) << 1) | (bit_sub<25,6>(instr) << 5) | (bit_sub<31,1>(instr) << 12));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs1}, {rs2}, {imm:#0x}", fmt::arg("mnemonic", "bge"),
                            fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs2 >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if((int32_t)*(X+rs1) >= (int32_t)*(X+rs2)) {
                                            uint32_t new_pc = (uint32_t)((uint64_t)(*PC) + (int64_t)((int16_t)sext<13>(imm)));
                                            if(new_pc % traits::INSTR_ALIGNMENT) {
                                                set_tval(new_pc);
                                                raise(0, 0);
                                            }
                                            else {
                                                *NEXT_PC = new_pc;
                                                this->core.reg.last_branch = 1;
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::BLTU: {
                    uint16_t imm = ((bit_sub<7,1>(instr) << 11) | (bit_sub<8,4>(instr) << 1) | (bit_sub<25,6>(instr) << 5) | (bit_sub<31,1>(instr) << 12));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs1}, {rs2}, {imm:#0x}", fmt::arg("mnemonic", "bltu"),
                            fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs2 >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*(X+rs1) < *(X+rs2)) {
                                            uint32_t new_pc = (uint32_t)((uint64_t)(*PC) + (int64_t)((int16_t)sext<13>(imm)));
                                            if(new_pc % traits::INSTR_ALIGNMENT) {
                                                set_tval(new_pc);
                                                raise(0, 0);
                                            }
                                            else {
                                                *NEXT_PC = new_pc;
                                                this->core.reg.last_branch = 1;
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::BGEU: {
                    uint16_t imm = ((bit_sub<7,1>(instr) << 11) | (bit_sub<8,4>(instr) << 1) | (bit_sub<25,6>(instr) << 5) | (bit_sub<31,1>(instr) << 12));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs1}, {rs2}, {imm:#0x}", fmt::arg("mnemonic", "bgeu"),
                            fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs2 >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*(X+rs1) >= *(X+rs2)) {
                                            uint32_t new_pc = (uint32_t)((uint64_t)(*PC) + (int64_t)((int16_t)sext<13>(imm)));
                                            if(new_pc % traits::INSTR_ALIGNMENT) {
                                                set_tval(new_pc);
                                                raise(0, 0);
                                            }
                                            else {
                                                *NEXT_PC = new_pc;
                                                this->core.reg.last_branch = 1;
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::LB: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint16_t imm = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {imm}({rs1})", fmt::arg("mnemonic", "lb"),
                            fmt::arg("rd", name(rd)), fmt::arg("imm", imm), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t load_address = (uint32_t)((uint64_t)(*(X+rs1)) + (int64_t)((int16_t)sext<12>(imm)));
                                        int8_t res_1 = super::template read_mem<int8_t>(traits::MEM, load_address);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        int8_t res = (int8_t)res_1;
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)res;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::LH: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint16_t imm = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {imm}({rs1})", fmt::arg("mnemonic", "lh"),
                            fmt::arg("rd", name(rd)), fmt::arg("imm", imm), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t load_address = (uint32_t)((uint64_t)(*(X+rs1)) + (int64_t)((int16_t)sext<12>(imm)));
                                        int16_t res_2 = super::template read_mem<int16_t>(traits::MEM, load_address);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        int16_t res = (int16_t)res_2;
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)res;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::LW: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint16_t imm = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {imm}({rs1})", fmt::arg("mnemonic", "lw"),
                            fmt::arg("rd", name(rd)), fmt::arg("imm", imm), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t load_address = (uint32_t)((uint64_t)(*(X+rs1)) + (int64_t)((int16_t)sext<12>(imm)));
                                        int32_t res_3 = super::template read_mem<int32_t>(traits::MEM, load_address);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        int32_t res = (int32_t)res_3;
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)res;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::LBU: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint16_t imm = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {imm}({rs1})", fmt::arg("mnemonic", "lbu"),
                            fmt::arg("rd", name(rd)), fmt::arg("imm", imm), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t load_address = (uint32_t)((uint64_t)(*(X+rs1)) + (int64_t)((int16_t)sext<12>(imm)));
                                        uint8_t res_4 = super::template read_mem<uint8_t>(traits::MEM, load_address);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        uint8_t res = res_4;
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)res;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::LHU: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint16_t imm = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {imm}({rs1})", fmt::arg("mnemonic", "lhu"),
                            fmt::arg("rd", name(rd)), fmt::arg("imm", imm), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t load_address = (uint32_t)((uint64_t)(*(X+rs1)) + (int64_t)((int16_t)sext<12>(imm)));
                                        uint16_t res_5 = super::template read_mem<uint16_t>(traits::MEM, load_address);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        uint16_t res = res_5;
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)res;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::SB: {
                    uint16_t imm = ((bit_sub<7,5>(instr)) | (bit_sub<25,7>(instr) << 5));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs2}, {imm}({rs1})", fmt::arg("mnemonic", "sb"),
                            fmt::arg("rs2", name(rs2)), fmt::arg("imm", imm), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs2 >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t store_address = (uint32_t)((uint64_t)(*(X+rs1)) + (int64_t)((int16_t)sext<12>(imm)));
                                        super::template write_mem<uint8_t>(traits::MEM, store_address, (uint8_t)*(X+rs2));
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::SH: {
                    uint16_t imm = ((bit_sub<7,5>(instr)) | (bit_sub<25,7>(instr) << 5));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs2}, {imm}({rs1})", fmt::arg("mnemonic", "sh"),
                            fmt::arg("rs2", name(rs2)), fmt::arg("imm", imm), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs2 >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t store_address = (uint32_t)((uint64_t)(*(X+rs1)) + (int64_t)((int16_t)sext<12>(imm)));
                                        super::template write_mem<uint16_t>(traits::MEM, store_address, (uint16_t)*(X+rs2));
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::SW: {
                    uint16_t imm = ((bit_sub<7,5>(instr)) | (bit_sub<25,7>(instr) << 5));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs2}, {imm}({rs1})", fmt::arg("mnemonic", "sw"),
                            fmt::arg("rs2", name(rs2)), fmt::arg("imm", imm), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs2 >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t store_address = (uint32_t)((uint64_t)(*(X+rs1)) + (int64_t)((int16_t)sext<12>(imm)));
                                        super::template write_mem<uint32_t>(traits::MEM, store_address, (uint32_t)*(X+rs2));
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::ADDI: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint16_t imm = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {imm}", fmt::arg("mnemonic", "addi"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)((uint64_t)(*(X+rs1)) + (int64_t)((int16_t)sext<12>(imm)));
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::SLTI: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint16_t imm = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {imm}", fmt::arg("mnemonic", "slti"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = ((int32_t)*(X+rs1) < (int16_t)sext<12>(imm))? 1 : 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::SLTIU: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint16_t imm = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {imm}", fmt::arg("mnemonic", "sltiu"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = (*(X+rs1) < (uint32_t)((int16_t)sext<12>(imm)))? 1 : 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::XORI: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint16_t imm = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {imm}", fmt::arg("mnemonic", "xori"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = *(X+rs1) ^ (uint32_t)((int16_t)sext<12>(imm));
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::ORI: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint16_t imm = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {imm}", fmt::arg("mnemonic", "ori"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = *(X+rs1) | (uint32_t)((int16_t)sext<12>(imm));
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::ANDI: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint16_t imm = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {imm}", fmt::arg("mnemonic", "andi"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = *(X+rs1) & (uint32_t)((int16_t)sext<12>(imm));
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::SLLI: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t shamt = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {shamt}", fmt::arg("mnemonic", "slli"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("shamt", shamt));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = *(X+rs1) << shamt;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::SRLI: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t shamt = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {shamt}", fmt::arg("mnemonic", "srli"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("shamt", shamt));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = *(X+rs1) >> shamt;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::SRAI: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t shamt = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {shamt}", fmt::arg("mnemonic", "srai"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("shamt", shamt));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = ((uint32_t)((int32_t)*(X+rs1) >> shamt));
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::ADD: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "add"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)((uint64_t)(*(X+rs1)) + (uint64_t)(*(X+rs2)));
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::SUB: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "sub"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)((uint64_t)(*(X+rs1)) - (uint64_t)(*(X+rs2)));
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::SLL: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "sll"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = *(X+rs1) << ((uint64_t)(*(X+rs2)) & ((uint64_t)(traits::XLEN) - (uint64_t)(1)));
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::SLT: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "slt"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = (int32_t)*(X+rs1) < (int32_t)*(X+rs2)? 1 : 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::SLTU: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "sltu"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = *(X+rs1) < *(X+rs2)? 1 : 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::XOR: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "xor"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = *(X+rs1) ^ *(X+rs2);
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::SRL: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "srl"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = *(X+rs1) >> ((uint64_t)(*(X+rs2)) & ((uint64_t)(traits::XLEN) - (uint64_t)(1)));
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::SRA: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "sra"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)((int32_t)*(X+rs1) >> ((uint64_t)(*(X+rs2)) & ((uint64_t)(traits::XLEN) - (uint64_t)(1))));
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::OR: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "or"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = *(X+rs1) | *(X+rs2);
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::AND: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "and"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = *(X+rs1) & *(X+rs2);
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FENCE: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t succ = ((bit_sub<20,4>(instr)));
                    uint8_t pred = ((bit_sub<24,4>(instr)));
                    uint8_t fm = ((bit_sub<28,4>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {pred}, {succ} ({fm} , {rs1}, {rd})", fmt::arg("mnemonic", "fence"),
                            fmt::arg("pred", pred), fmt::arg("succ", succ), fmt::arg("fm", fm), fmt::arg("rs1", name(rs1)), fmt::arg("rd", name(rd)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    super::template write_mem<uint32_t>(traits::FENCE, traits::fence, (uint8_t)pred << 4 | succ);
                                    if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::ECALL: {
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        //No disass specified, using instruction name
                        std::string mnemonic = "ecall";
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    raise(0, 11);
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::EBREAK: {
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        //No disass specified, using instruction name
                        std::string mnemonic = "ebreak";
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    raise(0, 3);
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::MRET: {
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        //No disass specified, using instruction name
                        std::string mnemonic = "mret";
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    leave(3);
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::WFI: {
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        //No disass specified, using instruction name
                        std::string mnemonic = "wfi";
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    wait(1);
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::CSRRW: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint16_t csr = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {csr}, {rs1}", fmt::arg("mnemonic", "csrrw"),
                            fmt::arg("rd", name(rd)), fmt::arg("csr", csr), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t xrs1 = *(X+rs1);
                                        if(rd != 0) {
                                            uint32_t res_6 = super::template read_mem<uint32_t>(traits::CSR, csr);
                                            if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                            uint32_t xrd = res_6;
                                            super::template write_mem<uint32_t>(traits::CSR, csr, xrs1);
                                            if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                            *(X+rd) = xrd;
                                        }
                                        else {
                                            super::template write_mem<uint32_t>(traits::CSR, csr, xrs1);
                                            if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::CSRRS: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint16_t csr = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {csr}, {rs1}", fmt::arg("mnemonic", "csrrs"),
                            fmt::arg("rd", name(rd)), fmt::arg("csr", csr), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t res_7 = super::template read_mem<uint32_t>(traits::CSR, csr);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        uint32_t xrd = res_7;
                                        uint32_t xrs1 = *(X+rs1);
                                        if(rs1 != 0) {
                                            super::template write_mem<uint32_t>(traits::CSR, csr, xrd | xrs1);
                                            if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        }
                                        if(rd != 0) {
                                            *(X+rd) = xrd;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::CSRRC: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint16_t csr = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {csr}, {rs1}", fmt::arg("mnemonic", "csrrc"),
                            fmt::arg("rd", name(rd)), fmt::arg("csr", csr), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t res_8 = super::template read_mem<uint32_t>(traits::CSR, csr);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        uint32_t xrd = res_8;
                                        uint32_t xrs1 = *(X+rs1);
                                        if(rs1 != 0) {
                                            super::template write_mem<uint32_t>(traits::CSR, csr, xrd & ~xrs1);
                                            if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        }
                                        if(rd != 0) {
                                            *(X+rd) = xrd;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::CSRRWI: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t zimm = ((bit_sub<15,5>(instr)));
                    uint16_t csr = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {csr}, {zimm:#0x}", fmt::arg("mnemonic", "csrrwi"),
                            fmt::arg("rd", name(rd)), fmt::arg("csr", csr), fmt::arg("zimm", zimm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t res_9 = super::template read_mem<uint32_t>(traits::CSR, csr);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        uint32_t xrd = res_9;
                                        super::template write_mem<uint32_t>(traits::CSR, csr, (uint32_t)zimm);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        if(rd != 0) {
                                            *(X+rd) = xrd;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::CSRRSI: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t zimm = ((bit_sub<15,5>(instr)));
                    uint16_t csr = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {csr}, {zimm:#0x}", fmt::arg("mnemonic", "csrrsi"),
                            fmt::arg("rd", name(rd)), fmt::arg("csr", csr), fmt::arg("zimm", zimm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t res_10 = super::template read_mem<uint32_t>(traits::CSR, csr);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        uint32_t xrd = res_10;
                                        if(zimm != 0) {
                                            super::template write_mem<uint32_t>(traits::CSR, csr, xrd | (uint32_t)zimm);
                                            if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        }
                                        if(rd != 0) {
                                            *(X+rd) = xrd;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::CSRRCI: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t zimm = ((bit_sub<15,5>(instr)));
                    uint16_t csr = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {csr}, {zimm:#0x}", fmt::arg("mnemonic", "csrrci"),
                            fmt::arg("rd", name(rd)), fmt::arg("csr", csr), fmt::arg("zimm", zimm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t res_11 = super::template read_mem<uint32_t>(traits::CSR, csr);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        uint32_t xrd = res_11;
                                        if(zimm != 0) {
                                            super::template write_mem<uint32_t>(traits::CSR, csr, xrd & ~((uint32_t)zimm));
                                            if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        }
                                        if(rd != 0) {
                                            *(X+rd) = xrd;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FENCE_I: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint16_t imm = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs1}, {rd}, {imm}", fmt::arg("mnemonic", "fence_i"),
                            fmt::arg("rs1", name(rs1)), fmt::arg("rd", name(rd)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    super::template write_mem<uint32_t>(traits::FENCE, traits::fencei, imm);
                                    if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::MUL: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "mul"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        int64_t res = (int64_t)((int32_t)*(X+rs1)) * (int64_t)((int32_t)*(X+rs2));
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)res;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::MULH: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "mulh"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        int64_t res = (int64_t)((int32_t)*(X+rs1)) * (int64_t)((int32_t)*(X+rs2));
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)(res >> traits::XLEN);
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::MULHSU: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "mulhsu"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        int64_t res = (int64_t)((int32_t)*(X+rs1)) * (uint64_t)(*(X+rs2));
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)(res >> traits::XLEN);
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::MULHU: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "mulhu"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint64_t res = (uint64_t)(*(X+rs1)) * (uint64_t)(*(X+rs2));
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)(res >> traits::XLEN);
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::DIV: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "div"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        int32_t dividend = (int32_t)*(X+rs1);
                                        int32_t divisor = (int32_t)*(X+rs2);
                                        if(rd != 0) {
                                            if(divisor != 0) {
                                                uint32_t MMIN = ((uint32_t)1) << ((uint64_t)(traits::XLEN) - (uint64_t)(1));
                                                if(*(X+rs1) == MMIN && divisor == - 1) {
                                                    *(X+rd) = MMIN;
                                                }
                                                else {
                                                    *(X+rd) = (uint32_t)(dividend / divisor);
                                                }
                                            }
                                            else {
                                                *(X+rd) = (uint32_t)- 1;
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::DIVU: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "divu"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*(X+rs2) != 0) {
                                            if(rd != 0) {
                                                *(X+rd) = *(X+rs1) / *(X+rs2);
                                            }
                                        }
                                        else {
                                            if(rd != 0) {
                                                *(X+rd) = (uint32_t)- 1;
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::REM: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "rem"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*(X+rs2) != 0) {
                                            uint32_t MMIN = (uint32_t)1 << ((uint64_t)(traits::XLEN) - (uint64_t)(1));
                                            if(*(X+rs1) == MMIN && (int32_t)*(X+rs2) == - 1) {
                                                if(rd != 0) {
                                                    *(X+rd) = 0;
                                                }
                                            }
                                            else {
                                                if(rd != 0) {
                                                    *(X+rd) = ((uint32_t)((int32_t)*(X+rs1) % (int32_t)*(X+rs2)));
                                                }
                                            }
                                        }
                                        else {
                                            if(rd != 0) {
                                                *(X+rd) = *(X+rs1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::REMU: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "remu"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*(X+rs2) != 0) {
                                            if(rd != 0) {
                                                *(X+rd) = *(X+rs1) % *(X+rs2);
                                            }
                                        }
                                        else {
                                            if(rd != 0) {
                                                *(X+rd) = *(X+rs1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::LRW: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rl = ((bit_sub<25,1>(instr)));
                    uint8_t aq = ((bit_sub<26,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {aq}, {rl}", fmt::arg("mnemonic", "lrw"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("aq", name(aq)), fmt::arg("rl", name(rl)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            uint32_t offs = *(X+rs1);
                                            int32_t res_12 = super::template read_mem<int32_t>(traits::MEM, offs);
                                            if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                            *(X+rd) = (uint32_t)((int32_t)res_12);
                                            super::template write_mem<uint8_t>(traits::RES, offs, (uint8_t)- 1);
                                            if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::SCW: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t rl = ((bit_sub<25,1>(instr)));
                    uint8_t aq = ((bit_sub<26,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}, {aq}, {rl}", fmt::arg("mnemonic", "scw"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)), fmt::arg("aq", name(aq)), fmt::arg("rl", name(rl)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t offs = *(X+rs1);
                                        uint8_t res_13 = super::template read_mem<uint8_t>(traits::RES, offs);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        uint32_t res1 = res_13;
                                        if(res1 != 0) {
                                            super::template write_mem<uint32_t>(traits::MEM, offs, (uint32_t)*(X+rs2));
                                            if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        }
                                        if(rd != 0) {
                                            *(X+rd) = res1? 0 : 1;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::AMOSWAPW: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t rl = ((bit_sub<25,1>(instr)));
                    uint8_t aq = ((bit_sub<26,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2} (aqu = {aq},rel = {rl})", fmt::arg("mnemonic", "amoswapw"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)), fmt::arg("aq", aq), fmt::arg("rl", rl));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t offs = *(X+rs1);
                                        uint32_t res = *(X+rs2);
                                        if(rd != 0) {
                                            int32_t res_14 = super::template read_mem<int32_t>(traits::MEM, offs);
                                            if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                            *(X+rd) = (uint32_t)((int32_t)res_14);
                                        }
                                        super::template write_mem<uint32_t>(traits::MEM, offs, (uint32_t)res);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::AMOADDW: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t rl = ((bit_sub<25,1>(instr)));
                    uint8_t aq = ((bit_sub<26,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2} (aqu = {aq},rel = {rl})", fmt::arg("mnemonic", "amoaddw"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)), fmt::arg("aq", aq), fmt::arg("rl", rl));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t offs = *(X+rs1);
                                        int32_t res_15 = super::template read_mem<int32_t>(traits::MEM, offs);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        int32_t res1 = (int32_t)res_15;
                                        int64_t res2 = (int64_t)(res1) + (int64_t)((int32_t)*(X+rs2));
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)res1;
                                        }
                                        super::template write_mem<uint32_t>(traits::MEM, offs, (uint32_t)res2);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::AMOXORW: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t rl = ((bit_sub<25,1>(instr)));
                    uint8_t aq = ((bit_sub<26,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2} (aqu = {aq},rel = {rl})", fmt::arg("mnemonic", "amoxorw"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)), fmt::arg("aq", aq), fmt::arg("rl", rl));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t offs = *(X+rs1);
                                        uint32_t res_16 = super::template read_mem<uint32_t>(traits::MEM, offs);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        uint32_t res1 = res_16;
                                        uint32_t res2 = res1 ^ (uint32_t)*(X+rs2);
                                        if(rd != 0) {
                                            *(X+rd) = ((uint32_t)(int32_t)(int32_t)res1);
                                        }
                                        super::template write_mem<uint32_t>(traits::MEM, offs, res2);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::AMOANDW: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t rl = ((bit_sub<25,1>(instr)));
                    uint8_t aq = ((bit_sub<26,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2} (aqu = {aq},rel = {rl})", fmt::arg("mnemonic", "amoandw"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)), fmt::arg("aq", aq), fmt::arg("rl", rl));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t offs = *(X+rs1);
                                        uint32_t res_17 = super::template read_mem<uint32_t>(traits::MEM, offs);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        uint32_t res1 = res_17;
                                        uint32_t res2 = res1 & (uint32_t)*(X+rs2);
                                        if(rd != 0) {
                                            *(X+rd) = ((uint32_t)(int32_t)(int32_t)res1);
                                        }
                                        super::template write_mem<uint32_t>(traits::MEM, offs, res2);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::AMOORW: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t rl = ((bit_sub<25,1>(instr)));
                    uint8_t aq = ((bit_sub<26,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2} (aqu = {aq},rel = {rl})", fmt::arg("mnemonic", "amoorw"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)), fmt::arg("aq", aq), fmt::arg("rl", rl));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t offs = *(X+rs1);
                                        uint32_t res_18 = super::template read_mem<uint32_t>(traits::MEM, offs);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        uint32_t res1 = res_18;
                                        uint32_t res2 = res1 | (uint32_t)*(X+rs2);
                                        if(rd != 0) {
                                            *(X+rd) = ((uint32_t)(int32_t)(int32_t)res1);
                                        }
                                        super::template write_mem<uint32_t>(traits::MEM, offs, res2);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::AMOMINW: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t rl = ((bit_sub<25,1>(instr)));
                    uint8_t aq = ((bit_sub<26,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2} (aqu = {aq},rel = {rl})", fmt::arg("mnemonic", "amominw"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)), fmt::arg("aq", aq), fmt::arg("rl", rl));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t offs = *(X+rs1);
                                        int32_t res_19 = super::template read_mem<int32_t>(traits::MEM, offs);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        int32_t res1 = (int32_t)res_19;
                                        uint32_t res2 = res1 > (int32_t)*(X+rs2)? (uint32_t)*(X+rs2) : ((uint32_t)res1);
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)res1;
                                        }
                                        super::template write_mem<uint32_t>(traits::MEM, offs, res2);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::AMOMAXW: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t rl = ((bit_sub<25,1>(instr)));
                    uint8_t aq = ((bit_sub<26,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2} (aqu = {aq},rel = {rl})", fmt::arg("mnemonic", "amomaxw"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)), fmt::arg("aq", aq), fmt::arg("rl", rl));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t offs = *(X+rs1);
                                        int32_t res_20 = super::template read_mem<int32_t>(traits::MEM, offs);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        int32_t res1 = (int32_t)res_20;
                                        uint32_t res2 = res1 < (int32_t)*(X+rs2)? (uint32_t)*(X+rs2) : ((uint32_t)res1);
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)res1;
                                        }
                                        super::template write_mem<uint32_t>(traits::MEM, offs, res2);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::AMOMINUW: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t rl = ((bit_sub<25,1>(instr)));
                    uint8_t aq = ((bit_sub<26,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2} (aqu = {aq},rel = {rl})", fmt::arg("mnemonic", "amominuw"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)), fmt::arg("aq", aq), fmt::arg("rl", rl));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t offs = *(X+rs1);
                                        uint32_t res_21 = super::template read_mem<uint32_t>(traits::MEM, offs);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        uint32_t res1 = res_21;
                                        uint32_t res2 = res1 > (uint32_t)*(X+rs2)? (uint32_t)*(X+rs2) : res1;
                                        if(rd != 0) {
                                            *(X+rd) = ((uint32_t)(int32_t)(int32_t)res1);
                                        }
                                        super::template write_mem<uint32_t>(traits::MEM, offs, res2);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::AMOMAXUW: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t rl = ((bit_sub<25,1>(instr)));
                    uint8_t aq = ((bit_sub<26,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2} (aqu = {aq},rel = {rl})", fmt::arg("mnemonic", "amomaxuw"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)), fmt::arg("aq", aq), fmt::arg("rl", rl));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t offs = *(X+rs1);
                                        uint32_t res_22 = super::template read_mem<uint32_t>(traits::MEM, offs);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        uint32_t res1 = res_22;
                                        uint32_t res2 = res1 < (int32_t)*(X+rs2)? (uint32_t)*(X+rs2) : res1;
                                        if(rd != 0) {
                                            *(X+rd) = ((uint32_t)(int32_t)(int32_t)res1);
                                        }
                                        super::template write_mem<uint32_t>(traits::MEM, offs, res2);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__ADDI4SPN: {
                    uint8_t rd = ((bit_sub<2,3>(instr)));
                    uint16_t imm = ((bit_sub<5,1>(instr) << 3) | (bit_sub<6,1>(instr) << 2) | (bit_sub<7,4>(instr) << 6) | (bit_sub<11,2>(instr) << 4));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {imm:#05x}", fmt::arg("mnemonic", "c.addi4spn"),
                            fmt::arg("rd", name(8+rd)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                                    if(imm) {
                                        *(X+rd + 8) = (uint32_t)((uint64_t)(*(X+2)) + (uint64_t)(imm));
                                    }
                                    else {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__LW: {
                    uint8_t rd = ((bit_sub<2,3>(instr)));
                    uint8_t uimm = ((bit_sub<5,1>(instr) << 6) | (bit_sub<6,1>(instr) << 2) | (bit_sub<10,3>(instr) << 3));
                    uint8_t rs1 = ((bit_sub<7,3>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {uimm:#05x}({rs1})", fmt::arg("mnemonic", "c.lw"),
                            fmt::arg("rd", name(8+rd)), fmt::arg("uimm", uimm), fmt::arg("rs1", name(8+rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        uint32_t offs = (uint32_t)((uint64_t)(*(X+rs1 + 8)) + (uint64_t)(uimm));
                        int32_t res_23 = super::template read_mem<int32_t>(traits::MEM, offs);
                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                        *(X+rd + 8) = (uint32_t)(int32_t)res_23;
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__SW: {
                    uint8_t rs2 = ((bit_sub<2,3>(instr)));
                    uint8_t uimm = ((bit_sub<5,1>(instr) << 6) | (bit_sub<6,1>(instr) << 2) | (bit_sub<10,3>(instr) << 3));
                    uint8_t rs1 = ((bit_sub<7,3>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs2}, {uimm:#05x}({rs1})", fmt::arg("mnemonic", "c.sw"),
                            fmt::arg("rs2", name(8+rs2)), fmt::arg("uimm", uimm), fmt::arg("rs1", name(8+rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        uint32_t offs = (uint32_t)((uint64_t)(*(X+rs1 + 8)) + (uint64_t)(uimm));
                        super::template write_mem<uint32_t>(traits::MEM, offs, (uint32_t)*(X+rs2 + 8));
                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__ADDI: {
                    uint8_t imm = ((bit_sub<2,5>(instr)) | (bit_sub<12,1>(instr) << 5));
                    uint8_t rs1 = ((bit_sub<7,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs1}, {imm:#05x}", fmt::arg("mnemonic", "c.addi"),
                            fmt::arg("rs1", name(rs1)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rs1 != 0) {
                                            *(X+rs1) = (uint32_t)((uint64_t)(*(X+rs1)) + (int64_t)((int8_t)sext<6>(imm)));
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__NOP: {
                    uint8_t nzimm = ((bit_sub<2,5>(instr)) | (bit_sub<12,1>(instr) << 5));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        //No disass specified, using instruction name
                        std::string mnemonic = "c.nop";
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__JAL: {
                    uint16_t imm = ((bit_sub<2,1>(instr) << 5) | (bit_sub<3,3>(instr) << 1) | (bit_sub<6,1>(instr) << 7) | (bit_sub<7,1>(instr) << 6) | (bit_sub<8,1>(instr) << 10) | (bit_sub<9,2>(instr) << 8) | (bit_sub<11,1>(instr) << 4) | (bit_sub<12,1>(instr) << 11));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {imm:#05x}", fmt::arg("mnemonic", "c.jal"),
                            fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        *(X+1) = (uint32_t)((uint64_t)(*PC) + (uint64_t)(2));
                        *NEXT_PC = (uint32_t)((uint64_t)(*PC) + (int64_t)((int16_t)sext<12>(imm)));
                        this->core.reg.last_branch = 1;
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__LI: {
                    uint8_t imm = ((bit_sub<2,5>(instr)) | (bit_sub<12,1>(instr) << 5));
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {imm:#05x}", fmt::arg("mnemonic", "c.li"),
                            fmt::arg("rd", name(rd)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)((int8_t)sext<6>(imm));
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__LUI: {
                    uint32_t imm = ((bit_sub<2,5>(instr) << 12) | (bit_sub<12,1>(instr) << 17));
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {imm:#05x}", fmt::arg("mnemonic", "c.lui"),
                            fmt::arg("rd", name(rd)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        if(imm == 0 || rd >= traits::RFS) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        if(rd != 0) {
                            *(X+rd) = (uint32_t)((int32_t)sext<18>(imm));
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__ADDI16SP: {
                    uint16_t nzimm = ((bit_sub<2,1>(instr) << 5) | (bit_sub<3,2>(instr) << 7) | (bit_sub<5,1>(instr) << 6) | (bit_sub<6,1>(instr) << 4) | (bit_sub<12,1>(instr) << 9));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {nzimm:#05x}", fmt::arg("mnemonic", "c.addi16sp"),
                            fmt::arg("nzimm", nzimm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                                    if(nzimm) {
                                        *(X+2) = (uint32_t)((uint64_t)(*(X+2)) + (int64_t)((int16_t)sext<10>(nzimm)));
                                    }
                                    else {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::__reserved_clui: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        //No disass specified, using instruction name
                        std::string mnemonic = ".reserved_clui";
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                                    raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__SRLI: {
                    uint8_t shamt = ((bit_sub<2,5>(instr)));
                    uint8_t rs1 = ((bit_sub<7,3>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs1}, {shamt}", fmt::arg("mnemonic", "c.srli"),
                            fmt::arg("rs1", name(8+rs1)), fmt::arg("shamt", shamt));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        *(X+rs1 + 8) = *(X+rs1 + 8) >> shamt;
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__SRAI: {
                    uint8_t shamt = ((bit_sub<2,5>(instr)));
                    uint8_t rs1 = ((bit_sub<7,3>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs1}, {shamt}", fmt::arg("mnemonic", "c.srai"),
                            fmt::arg("rs1", name(8+rs1)), fmt::arg("shamt", shamt));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        if(shamt) {
                            *(X+rs1 + 8) = (uint32_t)(((int32_t)*(X+rs1 + 8)) >> shamt);
                        }
                        else {
                            if(traits::XLEN == 128) {
                                *(X+rs1 + 8) = (uint32_t)(((int32_t)*(X+rs1 + 8)) >> 64);
                            }
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__ANDI: {
                    uint8_t imm = ((bit_sub<2,5>(instr)) | (bit_sub<12,1>(instr) << 5));
                    uint8_t rs1 = ((bit_sub<7,3>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs1}, {imm:#05x}", fmt::arg("mnemonic", "c.andi"),
                            fmt::arg("rs1", name(8+rs1)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        *(X+rs1 + 8) = (uint32_t)(*(X+rs1 + 8) & (int32_t)((int8_t)sext<6>(imm)));
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__SUB: {
                    uint8_t rs2 = ((bit_sub<2,3>(instr)));
                    uint8_t rd = ((bit_sub<7,3>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs2}", fmt::arg("mnemonic", "c.sub"),
                            fmt::arg("rd", name(8+rd)), fmt::arg("rs2", name(8+rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        *(X+rd + 8) = (uint32_t)((uint64_t)(*(X+rd + 8)) - (uint64_t)(*(X+rs2 + 8)));
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__XOR: {
                    uint8_t rs2 = ((bit_sub<2,3>(instr)));
                    uint8_t rd = ((bit_sub<7,3>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs2}", fmt::arg("mnemonic", "c.xor"),
                            fmt::arg("rd", name(8+rd)), fmt::arg("rs2", name(8+rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        *(X+rd + 8) = *(X+rd + 8) ^ *(X+rs2 + 8);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__OR: {
                    uint8_t rs2 = ((bit_sub<2,3>(instr)));
                    uint8_t rd = ((bit_sub<7,3>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs2}", fmt::arg("mnemonic", "c.or"),
                            fmt::arg("rd", name(8+rd)), fmt::arg("rs2", name(8+rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        *(X+rd + 8) = *(X+rd + 8) | *(X+rs2 + 8);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__AND: {
                    uint8_t rs2 = ((bit_sub<2,3>(instr)));
                    uint8_t rd = ((bit_sub<7,3>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs2}", fmt::arg("mnemonic", "c.and"),
                            fmt::arg("rd", name(8+rd)), fmt::arg("rs2", name(8+rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        *(X+rd + 8) = *(X+rd + 8) & *(X+rs2 + 8);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__J: {
                    uint16_t imm = ((bit_sub<2,1>(instr) << 5) | (bit_sub<3,3>(instr) << 1) | (bit_sub<6,1>(instr) << 7) | (bit_sub<7,1>(instr) << 6) | (bit_sub<8,1>(instr) << 10) | (bit_sub<9,2>(instr) << 8) | (bit_sub<11,1>(instr) << 4) | (bit_sub<12,1>(instr) << 11));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {imm:#05x}", fmt::arg("mnemonic", "c.j"),
                            fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                                    *NEXT_PC = (uint32_t)((uint64_t)(*PC) + (int64_t)((int16_t)sext<12>(imm)));
                                    this->core.reg.last_branch = 1;
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__BEQZ: {
                    uint16_t imm = ((bit_sub<2,1>(instr) << 5) | (bit_sub<3,2>(instr) << 1) | (bit_sub<5,2>(instr) << 6) | (bit_sub<10,2>(instr) << 3) | (bit_sub<12,1>(instr) << 8));
                    uint8_t rs1 = ((bit_sub<7,3>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs1}, {imm:#05x}", fmt::arg("mnemonic", "c.beqz"),
                            fmt::arg("rs1", name(8+rs1)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                                    if(*(X+rs1 + 8) == 0) {
                                        *NEXT_PC = (uint32_t)((uint64_t)(*PC) + (int64_t)((int16_t)sext<9>(imm)));
                                        this->core.reg.last_branch = 1;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__BNEZ: {
                    uint16_t imm = ((bit_sub<2,1>(instr) << 5) | (bit_sub<3,2>(instr) << 1) | (bit_sub<5,2>(instr) << 6) | (bit_sub<10,2>(instr) << 3) | (bit_sub<12,1>(instr) << 8));
                    uint8_t rs1 = ((bit_sub<7,3>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs1}, {imm:#05x}", fmt::arg("mnemonic", "c.bnez"),
                            fmt::arg("rs1", name(8+rs1)), fmt::arg("imm", imm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                                    if(*(X+rs1 + 8) != 0) {
                                        *NEXT_PC = (uint32_t)((uint64_t)(*PC) + (int64_t)((int16_t)sext<9>(imm)));
                                        this->core.reg.last_branch = 1;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__SLLI: {
                    uint8_t nzuimm = ((bit_sub<2,5>(instr)));
                    uint8_t rs1 = ((bit_sub<7,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs1}, {nzuimm}", fmt::arg("mnemonic", "c.slli"),
                            fmt::arg("rs1", name(rs1)), fmt::arg("nzuimm", nzuimm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rs1 != 0) {
                                            *(X+rs1) = *(X+rs1) << nzuimm;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__LWSP: {
                    uint8_t uimm = ((bit_sub<2,2>(instr) << 6) | (bit_sub<4,3>(instr) << 2) | (bit_sub<12,1>(instr) << 5));
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, sp, {uimm:#05x}", fmt::arg("mnemonic", "c.lwsp"),
                            fmt::arg("rd", name(rd)), fmt::arg("uimm", uimm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        if(rd >= traits::RFS || rd == 0) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            uint32_t offs = (uint32_t)((uint64_t)(*(X+2)) + (uint64_t)(uimm));
                            int32_t res_24 = super::template read_mem<int32_t>(traits::MEM, offs);
                            if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                            *(X+rd) = (uint32_t)(int32_t)res_24;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__MV: {
                    uint8_t rs2 = ((bit_sub<2,5>(instr)));
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs2}", fmt::arg("mnemonic", "c.mv"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = *(X+rs2);
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__JR: {
                    uint8_t rs1 = ((bit_sub<7,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs1}", fmt::arg("mnemonic", "c.jr"),
                            fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                                    if(rs1 && rs1 < traits::RFS) {
                                        uint32_t addr_mask = (uint32_t)- 2;
                                        *NEXT_PC = *(X+(uint32_t)(rs1) % traits::RFS) & addr_mask;
                                        this->core.reg.last_branch = 1;
                                    }
                                    else {
                                        raise(0, 2);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::__reserved_cmv: {
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        //No disass specified, using instruction name
                        std::string mnemonic = ".reserved_cmv";
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                                    raise(0, 2);
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__ADD: {
                    uint8_t rs2 = ((bit_sub<2,5>(instr)));
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs2}", fmt::arg("mnemonic", "c.add"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)((uint64_t)(*(X+rd)) + (uint64_t)(*(X+rs2)));
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__JALR: {
                    uint8_t rs1 = ((bit_sub<7,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs1}", fmt::arg("mnemonic", "c.jalr"),
                            fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t addr_mask = (uint32_t)- 2;
                                        uint32_t new_pc = *(X+rs1);
                                        *(X+1) = (uint32_t)((uint64_t)(*PC) + (uint64_t)(2));
                                        *NEXT_PC = new_pc & addr_mask;
                                        this->core.reg.last_branch = 1;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__EBREAK: {
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        //No disass specified, using instruction name
                        std::string mnemonic = "c.ebreak";
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                                    raise(0, 3);
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__SWSP: {
                    uint8_t rs2 = ((bit_sub<2,5>(instr)));
                    uint8_t uimm = ((bit_sub<7,2>(instr) << 6) | (bit_sub<9,4>(instr) << 2));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs2}, {uimm:#05x}(sp)", fmt::arg("mnemonic", "c.swsp"),
                            fmt::arg("rs2", name(rs2)), fmt::arg("uimm", uimm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                                    if(rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t offs = (uint32_t)((uint64_t)(*(X+2)) + (uint64_t)(uimm));
                                        super::template write_mem<uint32_t>(traits::MEM, offs, (uint32_t)*(X+rs2));
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::DII: {
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        //No disass specified, using instruction name
                        std::string mnemonic = "dii";
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                                    raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FLW: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint16_t imm = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {imm}({rs1})", fmt::arg("mnemonic", "flw"),
                            fmt::arg("rd", fname(rd)), fmt::arg("imm", imm), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t offs = (uint32_t)((uint64_t)(*(X+rs1)) + (int64_t)((int16_t)sext<12>(imm)));
                                        uint32_t res_25 = super::template read_mem<uint32_t>(traits::MEM, offs);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        *(F+rd) = NaNBox32(res_25);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FSW: {
                    uint16_t imm = ((bit_sub<7,5>(instr)) | (bit_sub<25,7>(instr) << 5));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs2}, {imm}({rs1})", fmt::arg("mnemonic", "fsw"),
                            fmt::arg("rs2", fname(rs2)), fmt::arg("imm", imm), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t offs = (uint32_t)((uint64_t)(*(X+rs1)) + (int64_t)((int16_t)sext<12>(imm)));
                                        super::template write_mem<uint32_t>(traits::MEM, offs, (uint32_t)*(F+rs2));
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FADD__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}, {rm}", fmt::arg("mnemonic", "fadd.s"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox32(fadd_s(unbox_s(traits::FLEN, *(F+rs1)), unbox_s(traits::FLEN, *(F+rs2)), get_rm(rm)));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FSUB__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}, {rm}", fmt::arg("mnemonic", "fsub.s"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox32(fsub_s(unbox_s(traits::FLEN, *(F+rs1)), unbox_s(traits::FLEN, *(F+rs2)), get_rm(rm)));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FMUL__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}, {rm}", fmt::arg("mnemonic", "fmul.s"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox32(fmul_s(unbox_s(traits::FLEN, *(F+rs1)), unbox_s(traits::FLEN, *(F+rs2)), get_rm(rm)));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FDIV__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}, {rm}", fmt::arg("mnemonic", "fdiv.s"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox32(fdiv_s(unbox_s(traits::FLEN, *(F+rs1)), unbox_s(traits::FLEN, *(F+rs2)), get_rm(rm)));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FMIN__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "fmin.s"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox32(fsel_s(unbox_s(traits::FLEN, *(F+rs1)), unbox_s(traits::FLEN, *(F+rs2)), 0));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FMAX__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "fmax.s"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox32(fsel_s(unbox_s(traits::FLEN, *(F+rs1)), unbox_s(traits::FLEN, *(F+rs2)), 1));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FSQRT__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rm}", fmt::arg("mnemonic", "fsqrt.s"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox32(fsqrt_s(unbox_s(traits::FLEN, *(F+rs1)), get_rm(rm)));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FMADD__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t rs3 = ((bit_sub<27,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}, {rs3}, {rm}", fmt::arg("mnemonic", "fmadd.s"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)), fmt::arg("rs3", fname(rs3)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox32(fmadd_s(unbox_s(traits::FLEN, *(F+rs1)), unbox_s(traits::FLEN, *(F+rs2)), unbox_s(traits::FLEN, *(F+rs3)), 0, get_rm(rm)));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FMSUB__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t rs3 = ((bit_sub<27,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}, {rs3}, {rm}", fmt::arg("mnemonic", "fmsub.s"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)), fmt::arg("rs3", fname(rs3)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox32(fmadd_s(unbox_s(traits::FLEN, *(F+rs1)), unbox_s(traits::FLEN, *(F+rs2)), unbox_s(traits::FLEN, *(F+rs3)), 1, get_rm(rm)));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FNMADD__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t rs3 = ((bit_sub<27,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}, {rs3}, {rm}", fmt::arg("mnemonic", "fnmadd.s"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)), fmt::arg("rs3", fname(rs3)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox32(fmadd_s(unbox_s(traits::FLEN, *(F+rs1)), unbox_s(traits::FLEN, *(F+rs2)), unbox_s(traits::FLEN, *(F+rs3)), 2, get_rm(rm)));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FNMSUB__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t rs3 = ((bit_sub<27,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}, {rs3}, {rm}", fmt::arg("mnemonic", "fnmsub.s"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)), fmt::arg("rs3", fname(rs3)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox32(fmadd_s(unbox_s(traits::FLEN, *(F+rs1)), unbox_s(traits::FLEN, *(F+rs2)), unbox_s(traits::FLEN, *(F+rs3)), 3, get_rm(rm)));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FCVT__W__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rm}", fmt::arg("mnemonic", "fcvt.w.s"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        int32_t res = (int32_t)(int32_t)f32toi32(unbox_s(traits::FLEN, *(F+rs1)), get_rm(rm));
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)res;
                                        }
                                        uint32_t flags = fget_flags();
                                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FCVT__WU__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rm}", fmt::arg("mnemonic", "fcvt.wu.s"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        int32_t res = (int32_t)(int32_t)f32toui32(unbox_s(traits::FLEN, *(F+rs1)), get_rm(rm));
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)res;
                                        }
                                        uint32_t flags = fget_flags();
                                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FCVT__S__W: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rm}", fmt::arg("mnemonic", "fcvt.s.w"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        *(F+rd) = NaNBox32(i32tof32((uint32_t)*(X+rs1), get_rm(rm)));
                                        uint32_t flags = fget_flags();
                                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FCVT__S__WU: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rm}", fmt::arg("mnemonic", "fcvt.s.wu"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        *(F+rd) = NaNBox32(ui32tof32((uint32_t)*(X+rs1), get_rm(rm)));
                                        uint32_t flags = fget_flags();
                                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FSGNJ__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "fsgnj.s"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox32(((uint32_t)bit_sub<31, 31-31+1>(unbox_s(traits::FLEN, *(F+rs2)))<<31)|bit_sub<0, 30-0+1>(unbox_s(traits::FLEN, *(F+rs1))));
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FSGNJN__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "fsgnjn.s"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox32(((uint32_t)(~bit_sub<31, 31-31+1>(unbox_s(traits::FLEN, *(F+rs2))))& ((1ULL << 1)-1)<<31)|bit_sub<0, 30-0+1>(unbox_s(traits::FLEN, *(F+rs1))));
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FSGNJX__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "fsgnjx.s"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox32((unbox_s(traits::FLEN, *(F+rs2)) & ((uint32_t)1 << 31)) ^ unbox_s(traits::FLEN, *(F+rs1)));
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FMV__X__W: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}", fmt::arg("mnemonic", "fmv.x.w"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", fname(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)(int32_t)(int32_t)*(F+rs1);
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FMV__W__X: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}", fmt::arg("mnemonic", "fmv.w.x"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        *(F+rd) = NaNBox32((uint32_t)*(X+rs1));
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FEQ__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "feq.s"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t res = fcmp_s(unbox_s(traits::FLEN, *(F+rs1)), unbox_s(traits::FLEN, *(F+rs2)), 0);
                                        if(rd != 0) {
                                            *(X+rd) = res;
                                        }
                                        uint32_t flags = fget_flags();
                                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FLT__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "flt.s"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t res = fcmp_s(unbox_s(traits::FLEN, *(F+rs1)), unbox_s(traits::FLEN, *(F+rs2)), 2);
                                        if(rd != 0) {
                                            *(X+rd) = res;
                                        }
                                        uint32_t flags = fget_flags();
                                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FLE__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "fle.s"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t res = fcmp_s(unbox_s(traits::FLEN, *(F+rs1)), unbox_s(traits::FLEN, *(F+rs2)), 1);
                                        if(rd != 0) {
                                            *(X+rd) = res;
                                        }
                                        uint32_t flags = fget_flags();
                                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FCLASS__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}", fmt::arg("mnemonic", "fclass.s"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", fname(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t res = fclass_s(unbox_s(traits::FLEN, *(F+rs1)));
                                        if(rd != 0) {
                                            *(X+rd) = res;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__FLW: {
                    uint8_t rd = ((bit_sub<2,3>(instr)));
                    uint8_t uimm = ((bit_sub<5,1>(instr) << 6) | (bit_sub<6,1>(instr) << 2) | (bit_sub<10,3>(instr) << 3));
                    uint8_t rs1 = ((bit_sub<7,3>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} f(8+{rd}), {uimm}({rs1})", fmt::arg("mnemonic", "c.flw"),
                            fmt::arg("rd", rd), fmt::arg("uimm", uimm), fmt::arg("rs1", name(8+rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        uint32_t offs = (uint32_t)((uint64_t)(*(X+rs1 + 8)) + (uint64_t)(uimm));
                        uint32_t res_26 = super::template read_mem<uint32_t>(traits::MEM, offs);
                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                        uint32_t res = (uint32_t)res_26;
                        *(F+rd + 8) = NaNBox32(res);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__FSW: {
                    uint8_t rs2 = ((bit_sub<2,3>(instr)));
                    uint8_t uimm = ((bit_sub<5,1>(instr) << 6) | (bit_sub<6,1>(instr) << 2) | (bit_sub<10,3>(instr) << 3));
                    uint8_t rs1 = ((bit_sub<7,3>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} f(8+{rs2}), {uimm}({rs1})", fmt::arg("mnemonic", "c.fsw"),
                            fmt::arg("rs2", rs2), fmt::arg("uimm", uimm), fmt::arg("rs1", name(8+rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        uint32_t offs = (uint32_t)((uint64_t)(*(X+rs1 + 8)) + (uint64_t)(uimm));
                        super::template write_mem<uint32_t>(traits::MEM, offs, (uint32_t)*(F+rs2 + 8));
                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__FLWSP: {
                    uint8_t uimm = ((bit_sub<2,2>(instr) << 6) | (bit_sub<4,3>(instr) << 2) | (bit_sub<12,1>(instr) << 5));
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} f {rd}, {uimm}(x2)", fmt::arg("mnemonic", "c.flwsp"),
                            fmt::arg("rd", rd), fmt::arg("uimm", uimm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        uint32_t offs = (uint32_t)((uint64_t)(*(X+2)) + (uint64_t)(uimm));
                        uint32_t res_27 = super::template read_mem<uint32_t>(traits::MEM, offs);
                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                        uint32_t res = (uint32_t)res_27;
                        *(F+rd) = NaNBox32(res);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__FSWSP: {
                    uint8_t rs2 = ((bit_sub<2,5>(instr)));
                    uint8_t uimm = ((bit_sub<7,2>(instr) << 6) | (bit_sub<9,4>(instr) << 2));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} f {rs2}, {uimm}(x2), ", fmt::arg("mnemonic", "c.fswsp"),
                            fmt::arg("rs2", rs2), fmt::arg("uimm", uimm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        uint32_t offs = (uint32_t)((uint64_t)(*(X+2)) + (uint64_t)(uimm));
                        super::template write_mem<uint32_t>(traits::MEM, offs, (uint32_t)*(F+rs2));
                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FLD: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint16_t imm = ((bit_sub<20,12>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {imm}({rs1})", fmt::arg("mnemonic", "fld"),
                            fmt::arg("rd", fname(rd)), fmt::arg("imm", imm), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t offs = (uint32_t)((uint64_t)(*(X+rs1)) + (int64_t)((int16_t)sext<12>(imm)));
                                        uint64_t res_28 = super::template read_mem<uint64_t>(traits::MEM, offs);
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                        *(F+rd) = NaNBox64(res_28);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FSD: {
                    uint16_t imm = ((bit_sub<7,5>(instr)) | (bit_sub<25,7>(instr) << 5));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs2}, {imm}({rs1})", fmt::arg("mnemonic", "fsd"),
                            fmt::arg("rs2", fname(rs2)), fmt::arg("imm", imm), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t offs = (uint32_t)((uint64_t)(*(X+rs1)) + (int64_t)((int16_t)sext<12>(imm)));
                                        super::template write_mem<uint64_t>(traits::MEM, offs, (uint64_t)*(F+rs2));
                                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FADD__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}, {rm}", fmt::arg("mnemonic", "fadd.d"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox64(fadd_d(unbox_d(traits::FLEN, *(F+rs1)), unbox_d(traits::FLEN, *(F+rs2)), get_rm(rm)));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FSUB__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}, {rm}", fmt::arg("mnemonic", "fsub.d"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox64(fsub_d(unbox_d(traits::FLEN, *(F+rs1)), unbox_d(traits::FLEN, *(F+rs2)), get_rm(rm)));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FMUL__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}, {rm}", fmt::arg("mnemonic", "fmul.d"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox64(fmul_d(unbox_d(traits::FLEN, *(F+rs1)), unbox_d(traits::FLEN, *(F+rs2)), get_rm(rm)));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FDIV__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}, {rm}", fmt::arg("mnemonic", "fdiv.d"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox64(fdiv_d(unbox_d(traits::FLEN, *(F+rs1)), unbox_d(traits::FLEN, *(F+rs2)), get_rm(rm)));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FMIN__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "fmin.d"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox64(fsel_d(unbox_d(traits::FLEN, *(F+rs1)), unbox_d(traits::FLEN, *(F+rs2)), 0));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FMAX__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "fmax.d"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox64(fsel_d(unbox_d(traits::FLEN, *(F+rs1)), unbox_d(traits::FLEN, *(F+rs2)), 1));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FSQRT__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rm}", fmt::arg("mnemonic", "fsqrt.d"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox64(fsqrt_d(unbox_d(traits::FLEN, *(F+rs1)), get_rm(rm)));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FMADD__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t rs3 = ((bit_sub<27,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}, {rs3}, {rm}", fmt::arg("mnemonic", "fmadd.d"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)), fmt::arg("rs3", fname(rs3)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox64(fmadd_d(unbox_d(traits::FLEN, *(F+rs1)), unbox_d(traits::FLEN, *(F+rs2)), unbox_d(traits::FLEN, *(F+rs3)), 0, get_rm(rm)));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FMSUB__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t rs3 = ((bit_sub<27,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}, {rs3}, {rm}", fmt::arg("mnemonic", "fmsub.d"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)), fmt::arg("rs3", fname(rs3)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint64_t res = NaNBox64(fmadd_d(unbox_d(traits::FLEN, *(F+rs1)), unbox_d(traits::FLEN, *(F+rs2)), unbox_d(traits::FLEN, *(F+rs3)), 1, get_rm(rm)));
                        *(F+rd) = res;
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FNMADD__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t rs3 = ((bit_sub<27,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}, {rs3}, {rm}", fmt::arg("mnemonic", "fnmadd.d"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)), fmt::arg("rs3", fname(rs3)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox64(fmadd_d(unbox_d(traits::FLEN, *(F+rs1)), unbox_d(traits::FLEN, *(F+rs2)), unbox_d(traits::FLEN, *(F+rs3)), 2, get_rm(rm)));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FNMSUB__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t rs3 = ((bit_sub<27,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}, {rs3}, {rm}", fmt::arg("mnemonic", "fnmsub.d"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)), fmt::arg("rs3", fname(rs3)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox64(fmadd_d(unbox_d(traits::FLEN, *(F+rs1)), unbox_d(traits::FLEN, *(F+rs2)), unbox_d(traits::FLEN, *(F+rs3)), 3, get_rm(rm)));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FCVT__W__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rm}", fmt::arg("mnemonic", "fcvt.w.d"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        int32_t res = (int32_t)(int32_t)f64toi32(unbox_d(traits::FLEN, *(F+rs1)), get_rm(rm));
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)res;
                                        }
                                        uint32_t flags = fget_flags();
                                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FCVT__WU__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rm}", fmt::arg("mnemonic", "fcvt.wu.d"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        int32_t res = (int32_t)(int32_t)f64toui32(unbox_d(traits::FLEN, *(F+rs1)), get_rm(rm));
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)res;
                                        }
                                        uint32_t flags = fget_flags();
                                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FCVT__D__W: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rm}", fmt::arg("mnemonic", "fcvt.d.w"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        *(F+rd) = NaNBox64(i32tof64((uint32_t)*(X+rs1), get_rm(rm)));
                                        uint32_t flags = fget_flags();
                                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FCVT__D__WU: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rm}", fmt::arg("mnemonic", "fcvt.d.wu"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        *(F+rd) = NaNBox64(ui32tof64((uint32_t)*(X+rs1), get_rm(rm)));
                                        uint32_t flags = fget_flags();
                                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FCVT__S__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rm}", fmt::arg("mnemonic", "fcvt.s.d"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox32(f64tof32(unbox_d(traits::FLEN, *(F+rs1)), get_rm(rm)));
                        uint32_t flags = fget_flags();
                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FCVT__D__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rm = ((bit_sub<12,3>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rm}", fmt::arg("mnemonic", "fcvt.d.s"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rm", rm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox64(f32tof64(unbox_s(traits::FLEN, *(F+rs1)), get_rm(rm)));
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FSGNJ__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "fsgnj.d"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox64(((uint64_t)bit_sub<63, 63-63+1>(unbox_d(traits::FLEN, *(F+rs2)))<<63)|bit_sub<0, 62-0+1>(unbox_d(traits::FLEN, *(F+rs1))));
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FSGNJN__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "fsgnjn.d"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox64(((uint64_t)(~bit_sub<63, 63-63+1>(unbox_d(traits::FLEN, *(F+rs2))))& ((1ULL << 1)-1)<<63)|bit_sub<0, 62-0+1>(unbox_d(traits::FLEN, *(F+rs1))));
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FSGNJX__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "fsgnjx.d"),
                            fmt::arg("rd", fname(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        *(F+rd) = NaNBox64((unbox_d(traits::FLEN, *(F+rs2)) & ((uint64_t)1 << 63)) ^ unbox_d(traits::FLEN, *(F+rs1)));
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FEQ__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "feq.d"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint64_t res = fcmp_d(unbox_d(traits::FLEN, *(F+rs1)), unbox_d(traits::FLEN, *(F+rs2)), 0);
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)res;
                                        }
                                        uint32_t flags = fget_flags();
                                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FLT__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "flt.d"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint64_t res = fcmp_d(unbox_d(traits::FLEN, *(F+rs1)), unbox_d(traits::FLEN, *(F+rs2)), 2);
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)res;
                                        }
                                        uint32_t flags = fget_flags();
                                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FLE__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "fle.d"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", fname(rs1)), fmt::arg("rs2", fname(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]); 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint64_t res = fcmp_d(unbox_d(traits::FLEN, *(F+rs1)), unbox_d(traits::FLEN, *(F+rs2)), 1);
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)res;
                                        }
                                        uint32_t flags = fget_flags();
                                        *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::FCLASS__D: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}", fmt::arg("mnemonic", "fclass.d"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", fname(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint64_t res = fclass_d(unbox_d(traits::FLEN, *(F+rs1)));
                                        if(rd != 0) {
                                            *(X+rd) = (uint32_t)res;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__FLD: {
                    uint8_t rd = ((bit_sub<2,3>(instr)));
                    uint8_t uimm = ((bit_sub<5,2>(instr) << 6) | (bit_sub<10,3>(instr) << 3));
                    uint8_t rs1 = ((bit_sub<7,3>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} f(8+{rd}), {uimm}({rs1})", fmt::arg("mnemonic", "c.fld"),
                            fmt::arg("rd", rd), fmt::arg("uimm", uimm), fmt::arg("rs1", name(8+rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        uint32_t offs = (uint32_t)((uint64_t)(*(X+rs1 + 8)) + (uint64_t)(uimm));
                        uint64_t res_29 = super::template read_mem<uint64_t>(traits::MEM, offs);
                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                        uint64_t res = (uint64_t)res_29;
                        *(F+rd + 8) = NaNBox64(res);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__FSD: {
                    uint8_t rs2 = ((bit_sub<2,3>(instr)));
                    uint8_t uimm = ((bit_sub<5,2>(instr) << 6) | (bit_sub<10,3>(instr) << 3));
                    uint8_t rs1 = ((bit_sub<7,3>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} f(8+{rs2}), {uimm}({rs1})", fmt::arg("mnemonic", "c.fsd"),
                            fmt::arg("rs2", rs2), fmt::arg("uimm", uimm), fmt::arg("rs1", name(8+rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        uint32_t offs = (uint32_t)((uint64_t)(*(X+rs1 + 8)) + (uint64_t)(uimm));
                        super::template write_mem<uint64_t>(traits::MEM, offs, (uint64_t)*(F+rs2 + 8));
                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__FLDSP: {
                    uint16_t uimm = ((bit_sub<2,3>(instr) << 6) | (bit_sub<5,2>(instr) << 3) | (bit_sub<12,1>(instr) << 5));
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} f {rd}, {uimm}(x2)", fmt::arg("mnemonic", "c.fldsp"),
                            fmt::arg("rd", rd), fmt::arg("uimm", uimm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        uint32_t offs = (uint32_t)((uint64_t)(*(X+2)) + (uint64_t)(uimm));
                        uint64_t res_30 = super::template read_mem<uint64_t>(traits::MEM, offs);
                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                        uint64_t res = (uint64_t)res_30;
                        *(F+rd) = NaNBox64(res);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::C__FSDSP: {
                    uint8_t rs2 = ((bit_sub<2,5>(instr)));
                    uint16_t uimm = ((bit_sub<7,3>(instr) << 6) | (bit_sub<10,3>(instr) << 3));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} f {rs2}, {uimm}(x2), ", fmt::arg("mnemonic", "c.fsdsp"),
                            fmt::arg("rs2", rs2), fmt::arg("uimm", uimm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 2;
                    // execute instruction
                    {
                        uint32_t offs = (uint32_t)((uint64_t)(*(X+2)) + (uint64_t)(uimm));
                        super::template write_mem<uint64_t>(traits::MEM, offs, (uint64_t)*(F+rs2));
                        if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::SFENCE__VMA: {
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t asid = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs1}, {asid}", fmt::arg("mnemonic", "sfence.vma"),
                            fmt::arg("rs1", name(rs1)), fmt::arg("asid", name(asid)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    super::template write_mem<uint32_t>(traits::FENCE, traits::fencevma, ((uint16_t)(uint8_t)rs1<<8)|(uint8_t)asid);
                                    if(this->core.reg.trap_state>=0x80000000UL) throw memory_access_exception();
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::SRET: {
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        //No disass specified, using instruction name
                        std::string mnemonic = "sret";
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    leave(1);
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSETVLI: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t lmul = ((bit_sub<20,3>(instr)));
                    uint8_t sew = ((bit_sub<23,3>(instr)));
                    uint8_t ta = ((bit_sub<26,1>(instr)));
                    uint8_t ma = ((bit_sub<27,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {sew}, {lmul}, {ta}, {ma}", fmt::arg("mnemonic", "vsetvli"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("sew", sew_name(sew)), fmt::arg("lmul", lmul_name(lmul)), fmt::arg("ta", ta_name(ta)), fmt::arg("ma", ma_name(ma)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t orig_ratio = (uint8_t)(get_sew_pow() - get_lmul_pow());
                                        uint32_t orig_vstart = *vstart;
                                        *vstart = 0;
                                        *vtype = (uint32_t)((ma<<7)|(ta<<6)|(sew<<3)|lmul);
                                        if(! valid_sew_lmul()) {
                                            handle_illegal_vtype();
                                            *vstart = orig_vstart;
                                        }
                                        else {
                                            uint16_t VLMAX = (uint16_t)(1 << ((uint16_t)(get_pow(traits::VLEN)) + (int16_t)(get_lmul_pow()) - (uint16_t)(get_sew_pow()))) & ~1;
                                            if(rs1 != 0) {
                                                uint32_t AVL = *(X+rs1);
                                                *vl = (uint32_t)calculate_new_vl(AVL, VLMAX);
                                                if(rd != 0) {
                                                    *(X+rd) = *vl;
                                                }
                                            }
                                            else {
                                                if(rd != 0) {
                                                    *vl = VLMAX;
                                                    *(X+rd) = (uint32_t)VLMAX;
                                                }
                                                else {
                                                    uint8_t new_ratio = (uint8_t)(get_sew_pow() - get_lmul_pow());
                                                    if(orig_ratio != new_ratio) {
                                                        handle_illegal_vtype();
                                                        *vstart = orig_vstart;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSETIVLI: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t uimm = ((bit_sub<15,5>(instr)));
                    uint8_t lmul = ((bit_sub<20,3>(instr)));
                    uint8_t sew = ((bit_sub<23,3>(instr)));
                    uint8_t ta = ((bit_sub<26,1>(instr)));
                    uint8_t ma = ((bit_sub<27,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {uimm}, {sew}, {lmul}, {ta}, {ma}", fmt::arg("mnemonic", "vsetivli"),
                            fmt::arg("rd", name(rd)), fmt::arg("uimm", uimm), fmt::arg("sew", sew_name(sew)), fmt::arg("lmul", lmul_name(lmul)), fmt::arg("ta", ta_name(ta)), fmt::arg("ma", ma_name(ma)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        *vtype = (uint32_t)((ma<<7)|(ta<<6)|(sew<<3)|lmul);
                                        if(! valid_sew_lmul()) {
                                            handle_illegal_vtype();
                                        }
                                        else {
                                            uint16_t VLMAX = (uint16_t)(1 << ((uint16_t)(get_pow(traits::VLEN)) + (int16_t)(get_lmul_pow()) - (uint16_t)(get_sew_pow()))) & ~1;
                                            *vl = calculate_new_vl(uimm, VLMAX);
                                            if(rd != 0) {
                                                *(X+rd) = *vl;
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSETVL: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {rs1}, {rs2}", fmt::arg("mnemonic", "vsetvl"),
                            fmt::arg("rd", name(rd)), fmt::arg("rs1", name(rs1)), fmt::arg("rs2", name(rs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t orig_ratio = (uint8_t)(get_sew_pow() - get_lmul_pow());
                                        uint32_t orig_vstart = *vstart;
                                        *vstart = 0;
                                        if(bit_sub<uint32_t>(*(X+rs2), 8, ((uint64_t)(traits::XLEN) - (uint64_t)(2))-8+1)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        *vtype = *(X+rs2);
                                        if(! valid_sew_lmul()) {
                                            handle_illegal_vtype();
                                            *vstart = orig_vstart;
                                        }
                                        else {
                                            uint16_t VLMAX = (uint16_t)(1 << ((uint16_t)(get_pow(traits::VLEN)) + (int16_t)(get_lmul_pow()) - (uint16_t)(get_sew_pow()))) & ~1;
                                            if(rs1 != 0) {
                                                uint32_t AVL = *(X+rs1);
                                                *vl = (uint32_t)calculate_new_vl(AVL, VLMAX);
                                                if(rd != 0) {
                                                    *(X+rd) = *vl;
                                                }
                                            }
                                            else {
                                                if(rd != 0) {
                                                    *vl = VLMAX;
                                                    *(X+rd) = (uint32_t)VLMAX;
                                                }
                                                else {
                                                    uint8_t new_ratio = (uint8_t)(get_sew_pow() - get_lmul_pow());
                                                    uint8_t vill = bit_sub<uint32_t>(*vtype, (uint64_t)(traits::XLEN) - (uint64_t)(1), 1);
                                                    if(vill || (orig_ratio != new_ratio)) {
                                                        handle_illegal_vtype();
                                                        *vstart = orig_vstart;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLE8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vle8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 1, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLE16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vle16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 1, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLE32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vle32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 1, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLE64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vle64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 1, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG2E8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg2e8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 2, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 2);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG2E16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg2e16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 2, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 2);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG2E32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg2e32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 2, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 2);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG2E64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg2e64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 2, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 2);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG3E8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg3e8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 3, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 3);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG3E16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg3e16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 3, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 3);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG3E32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg3e32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 3, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 3);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG3E64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg3e64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 3, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 3);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG4E8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg4e8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 4, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 4);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG4E16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg4e16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 4, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 4);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG4E32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg4e32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 4, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 4);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG4E64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg4e64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 4, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 4);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG5E8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg5e8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 5, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 5);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG5E16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg5e16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 5, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 5);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG5E32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg5e32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 5, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 5);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG5E64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg5e64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 5, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 5);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG6E8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg6e8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 6, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 6);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG6E16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg6e16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 6, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 6);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG6E32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg6e32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 6, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 6);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG6E64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg6e64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 6, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 6);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG7E8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg7e8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 7, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 7);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG7E16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg7e16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 7, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 7);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG7E32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg7e32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 7, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 7);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG7E64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg7e64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 7, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 7);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG8E8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg8e8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 8, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 8);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG8E16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg8e16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 8, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 8);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG8E32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg8e32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 8, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 8);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG8E64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlseg8e64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 8, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 8);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSE8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vse8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(1, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 0, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSE16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vse16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(1, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 5, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSE32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vse32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(1, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 6, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSE64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vse64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(1, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 7, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG2E8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg2e8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(2, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 0, 2);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG2E16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg2e16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(2, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 5, 2);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG2E32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg2e32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(2, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 6, 2);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG2E64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg2e64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(2, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 7, 2);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG3E8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg3e8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(3, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 0, 3);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG3E16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg3e16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(3, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 5, 3);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG3E32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg3e32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(3, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 6, 3);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG3E64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg3e64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(3, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 7, 3);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG4E8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg4e8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(4, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 0, 4);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG4E16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg4e16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(4, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 5, 4);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG4E32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg4e32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(4, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 6, 4);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG4E64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg4e64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(4, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 7, 4);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG5E8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg5e8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(5, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 0, 5);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG5E16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg5e16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(5, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 5, 5);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG5E32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg5e32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(5, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 6, 5);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG5E64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg5e64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(5, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 7, 5);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG6E8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg6e8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(6, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 0, 6);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG6E16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg6e16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(6, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 5, 6);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG6E32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg6e32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(6, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 6, 6);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG6E64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg6e64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(6, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 7, 6);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG7E8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg7e8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(7, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 0, 7);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG7E16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg7e16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(7, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 5, 7);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG7E32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg7e32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(7, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 6, 7);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG7E64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg7e64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(7, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 7, 7);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG8E8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg8e8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(8, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 0, 8);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG8E16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg8e16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(8, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 5, 8);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG8E32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg8e32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(8, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 6, 8);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSEG8E64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsseg8e64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(8, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 7, 8);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSE8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlse8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 1, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 1, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSE16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlse16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 1, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 1, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSE32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlse32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 1, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 1, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSE64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlse64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 1, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 1, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG2E8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg2e8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 2, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 2, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG2E16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg2e16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 2, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 2, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG2E32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg2e32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 2, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 2, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG2E64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg2e64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 2, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 2, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG3E8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg3e8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 3, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 3, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG3E16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg3e16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 3, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 3, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG3E32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg3e32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 3, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 3, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG3E64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg3e64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 3, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 3, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG4E8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg4e8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 4, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 4, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG4E16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg4e16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 4, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 4, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG4E32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg4e32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 4, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 4, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG4E64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg4e64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 4, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 4, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG5E8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg5e8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 5, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 5, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG5E16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg5e16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 5, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 5, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG5E32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg5e32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 5, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 5, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG5E64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg5e64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 5, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 5, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG6E8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg6e8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 6, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 6, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG6E16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg6e16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 6, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 6, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG6E32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg6e32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 6, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 6, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG6E64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg6e64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 6, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 6, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG7E8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg7e8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 7, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 7, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG7E16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg7e16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 7, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 7, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG7E32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg7e32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 7, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 7, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG7E64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg7e64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 7, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 7, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG8E8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg8e8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 8, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 8, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG8E16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg8e16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 8, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 8, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG8E32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg8e32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 8, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 8, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSSEG8E64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vm}", fmt::arg("mnemonic", "vlsseg8e64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 8, EEW, EMUL_pow)) {
                                            raise(0, 2);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlsseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 8, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSE8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsse8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(1, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 0, 1, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSE16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsse16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(1, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 5, 1, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSE32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsse32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(1, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 6, 1, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSE64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vsse64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(1, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 7, 1, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG2E8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg2e8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(2, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 0, 2, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG2E16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg2e16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(2, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 5, 2, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG2E32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg2e32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(2, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 6, 2, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG2E64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg2e64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(2, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 7, 2, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG3E8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg3e8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(3, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 0, 3, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG3E16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg3e16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(3, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 5, 3, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG3E32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg3e32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(3, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 6, 3, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG3E64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg3e64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(3, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 7, 3, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG4E8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg4e8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(4, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 0, 4, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG4E16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg4e16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(4, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 5, 4, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG4E32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg4e32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(4, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 6, 4, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG4E64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg4e64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(4, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 7, 4, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG5E8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg5e8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(5, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 0, 5, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG5E16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg5e16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(5, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 5, 5, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG5E32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg5e32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(5, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 6, 5, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG5E64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg5e64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(5, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 7, 5, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG6E8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg6e8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(6, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 0, 6, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG6E16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg6e16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(6, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 5, 6, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG6E32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg6e32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(6, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 6, 6, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG6E64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg6e64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(6, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 7, 6, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG7E8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg7e8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(7, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 0, 7, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG7E16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg7e16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(7, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 5, 7, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG7E32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg7e32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(7, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 6, 7, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG7E64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg7e64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(7, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 7, 7, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG8E8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg8e8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(8, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 0, 8, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG8E16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg8e16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(8, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 5, 8, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG8E32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg8e32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(8, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 6, 8, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSSEG8E64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t rs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vm}", fmt::arg("mnemonic", "vssseg8e64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || rs2 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_store(8, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vssseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), 7, 8, (int32_t)*(X+rs2));
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLE8FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vle8ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 1, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 1);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLE16FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vle16ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 1, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 1);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLE32FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vle32ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 1, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 1);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLE64FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vle64ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 1, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 1);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG2E8FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg2e8ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 2, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 2);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG2E16FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg2e16ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 2, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 2);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG2E32FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg2e32ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 2, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 2);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG2E64FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg2e64ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 2, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 2);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG3E8FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg3e8ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 3, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 3);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG3E16FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg3e16ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 3, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 3);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG3E32FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg3e32ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 3, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 3);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG3E64FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg3e64ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 3, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 3);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG4E8FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg4e8ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 4, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 4);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG4E16FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg4e16ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 4, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 4);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG4E32FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg4e32ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 4, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 4);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG4E64FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg4e64ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 4, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 4);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG5E8FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg5e8ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 5, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 5);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG5E16FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg5e16ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 5, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 5);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG5E32FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg5e32ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 5, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 5);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG5E64FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg5e64ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 5, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 5);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG6E8FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg6e8ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 6, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 6);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG6E16FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg6e16ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 6, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 6);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG6E32FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg6e32ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 6, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 6);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG6E64FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg6e64ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 6, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 6);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG7E8FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg7e8ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 7, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 7);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG7E16FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg7e16ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 7, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 7);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG7E32FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg7e32ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 7, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 7);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG7E64FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg7e64ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 7, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 7);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG8E8FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg8e8ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 8, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 0, 8);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG8E16FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg8e16ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 8, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 5, 8);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG8E32FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg8e32ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 8, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 6, 8);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLSEG8E64FF__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vlseg8e64ff.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_load(vd, vm, 8, EEW, EMUL_pow)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            uint64_t trapped_idx = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), 7, 8);
                                            if(trapped_idx != 1) {
                                                *vl = (uint32_t)trapped_idx;
                                                lower();
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSM__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs1}, {vs3}", fmt::arg("mnemonic", "vsm.v"),
                            fmt::arg("rs1", name(rs1)), fmt::arg("vs3", vname(vs3)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = *vl % (uint32_t)(8) == 0? *vl / (uint32_t)(8) : (uint32_t)((uint64_t)(*vl / (uint32_t)(8)) + (uint64_t)(1));
                                        if(illegal_vd_unmasked()) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        uint32_t _vtype = (bit_sub<uint32_t>(*vtype, 7, (uint64_t)(traits::XLEN) - (uint64_t)(1)-7+1)<<7)|((uint32_t)1<<6)|((uint32_t)0<<3)|bit_sub<0, 2-0+1>(*vtype);
                                        *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, evl, *vstart, _vtype, 1, vs3, *(X+rs1), 0, 1);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLM__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rs1}, {vd}", fmt::arg("mnemonic", "vlm.v"),
                            fmt::arg("rs1", name(rs1)), fmt::arg("vd", vname(vd)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = *vl % (uint32_t)(8) == 0? *vl / (uint32_t)(8) : (uint32_t)((uint64_t)(*vl / (uint32_t)(8)) + (uint64_t)(1));
                                        if(illegal_vd_unmasked()) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        uint32_t _vtype = (bit_sub<uint32_t>(*vtype, 7, (uint64_t)(traits::XLEN) - (uint64_t)(1)-7+1)<<7)|((uint32_t)1<<6)|((uint32_t)0<<3)|bit_sub<0, 2-0+1>(*vtype);
                                        *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, evl, *vstart, _vtype, 1, vd, *(X+rs1), 0, 1);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VL1RE8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vl1re8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(1) * (uint64_t)(traits::VLEN) / (uint64_t)(8));
                                        if(evl > *vstart) {
                                            *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vd, *(X+rs1), 0, 1);
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VL1RE16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vl1re16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(1) * (uint64_t)(traits::VLEN) / (uint64_t)(16));
                                        if(evl > *vstart) {
                                            *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vd, *(X+rs1), 5, 1);
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VL1RE32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vl1re32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(1) * (uint64_t)(traits::VLEN) / (uint64_t)(32));
                                        if(evl > *vstart) {
                                            *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vd, *(X+rs1), 6, 1);
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VL1RE64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vl1re64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(1) * (uint64_t)(traits::VLEN) / (uint64_t)(64));
                                        if(evl > *vstart) {
                                            *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vd, *(X+rs1), 7, 1);
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VL2RE8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vl2re8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(2) * (uint64_t)(traits::VLEN) / (uint64_t)(8));
                                        if(vd % 2) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(evl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vd, *(X+rs1), 0, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VL2RE16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vl2re16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(2) * (uint64_t)(traits::VLEN) / (uint64_t)(16));
                                        if(vd % 2) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(evl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vd, *(X+rs1), 5, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VL2RE32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vl2re32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(2) * (uint64_t)(traits::VLEN) / (uint64_t)(32));
                                        if(vd % 2) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(evl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vd, *(X+rs1), 6, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VL2RE64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vl2re64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(2) * (uint64_t)(traits::VLEN) / (uint64_t)(64));
                                        if(vd % 2) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(evl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vd, *(X+rs1), 7, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VL4RE8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vl4re8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(4) * (uint64_t)(traits::VLEN) / (uint64_t)(8));
                                        if(vd % 4) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(evl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vd, *(X+rs1), 0, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VL4RE16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vl4re16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(4) * (uint64_t)(traits::VLEN) / (uint64_t)(16));
                                        if(vd % 4) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(evl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vd, *(X+rs1), 5, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VL4RE32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vl4re32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(4) * (uint64_t)(traits::VLEN) / (uint64_t)(32));
                                        if(vd % 4) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(evl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vd, *(X+rs1), 6, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VL4RE64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vl4re64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(4) * (uint64_t)(traits::VLEN) / (uint64_t)(64));
                                        if(vd % 4) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(evl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vd, *(X+rs1), 7, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VL8RE8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vl8re8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(8) * (uint64_t)(traits::VLEN) / (uint64_t)(8));
                                        if(vd % 8) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(evl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vd, *(X+rs1), 0, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VL8RE16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vl8re16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(8) * (uint64_t)(traits::VLEN) / (uint64_t)(16));
                                        if(vd % 8) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(evl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vd, *(X+rs1), 5, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VL8RE32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vl8re32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(8) * (uint64_t)(traits::VLEN) / (uint64_t)(32));
                                        if(vd % 8) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(evl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vd, *(X+rs1), 6, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VL8RE64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1})", fmt::arg("mnemonic", "vl8re64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(8) * (uint64_t)(traits::VLEN) / (uint64_t)(64));
                                        if(vd % 8) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(evl > *vstart) {
                                                *vstart = (uint32_t)vlseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vd, *(X+rs1), 7, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VS1RE64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1})", fmt::arg("mnemonic", "vs1re64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(1) * (uint64_t)(traits::VLEN) / (uint64_t)(8));
                                        if(evl > *vstart) {
                                            *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vs3, *(X+rs1), 0, 1);
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VS2RE64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1})", fmt::arg("mnemonic", "vs2re64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(2) * (uint64_t)(traits::VLEN) / (uint64_t)(8));
                                        if(vs3 % 2) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(evl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vs3, *(X+rs1), 0, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VS4RE64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1})", fmt::arg("mnemonic", "vs4re64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(4) * (uint64_t)(traits::VLEN) / (uint64_t)(8));
                                        if(vs3 % 4) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(evl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vs3, *(X+rs1), 0, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VS8RE64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1})", fmt::arg("mnemonic", "vs8re64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint32_t evl = (uint32_t)((uint64_t)(8) * (uint64_t)(traits::VLEN) / (uint64_t)(8));
                                        if(vs3 % 8) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(evl > *vstart) {
                                                *vstart = (uint32_t)vsseg(this->get_arch(), (uint8_t*)V, evl, *vstart, *vtype, 1, vs3, *(X+rs1), 0, 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXEI8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxei8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 1, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 1, 1, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXEI16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxei16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 1, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 1, 2, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXEI32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxei32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 1, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 1, 4, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXEI64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxei64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 1, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 1, 8, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG2EI8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg2ei8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 2, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 2, 1, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG2EI16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg2ei16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 2, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 2, 2, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG2EI32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg2ei32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 2, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 2, 4, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG2EI64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg2ei64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 2, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 2, 8, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG3EI8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg3ei8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 3, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 3, 1, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG3EI16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg3ei16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 3, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 3, 2, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG3EI32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg3ei32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 3, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 3, 4, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG3EI64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg3ei64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 3, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 3, 8, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG4EI8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg4ei8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 4, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 4, 1, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG4EI16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg4ei16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 4, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 4, 2, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG4EI32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg4ei32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 4, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 4, 4, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG4EI64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg4ei64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 4, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 4, 8, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG5EI8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg5ei8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 5, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 5, 1, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG5EI16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg5ei16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 5, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 5, 2, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG5EI32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg5ei32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 5, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 5, 4, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG5EI64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg5ei64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 5, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 5, 8, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG6EI8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg6ei8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 6, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 6, 1, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG6EI16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg6ei16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 6, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 6, 2, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG6EI32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg6ei32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 6, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 6, 4, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG6EI64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg6ei64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 6, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 6, 8, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG7EI8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg7ei8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 7, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 7, 1, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG7EI16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg7ei16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 7, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 7, 2, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG7EI32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg7ei32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 7, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 7, 4, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG7EI64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg7ei64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 7, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 7, 8, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG8EI8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg8ei8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 8, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 8, 1, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG8EI16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg8ei16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 8, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 8, 2, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG8EI32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg8ei32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 8, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 8, 4, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLOXSEG8EI64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vloxseg8ei64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 8, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 8, 8, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXEI8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxei8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(1, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 1, 1, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXEI16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxei16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(1, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 1, 2, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXEI32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxei32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(1, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 1, 4, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXEI64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxei64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(1, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 1, 8, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG2EI8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg2ei8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(2, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 2, 1, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG2EI16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg2ei16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(2, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 2, 2, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG2EI32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg2ei32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(2, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 2, 4, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG2EI64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg2ei64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(2, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 2, 8, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG3EI8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg3ei8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(3, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 3, 1, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG3EI16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg3ei16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(3, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 3, 2, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG3EI32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg3ei32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(3, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 3, 4, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG3EI64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg3ei64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(3, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 3, 8, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG4EI8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg4ei8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(4, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 4, 1, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG4EI16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg4ei16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(4, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 4, 2, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG4EI32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg4ei32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(4, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 4, 4, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG4EI64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg4ei64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(4, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 4, 8, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG5EI8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg5ei8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(5, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 5, 1, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG5EI16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg5ei16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(5, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 5, 2, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG5EI32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg5ei32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(5, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 5, 4, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG5EI64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg5ei64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(5, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 5, 8, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG6EI8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg6ei8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(6, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 6, 1, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG6EI16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg6ei16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(6, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 6, 2, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG6EI32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg6ei32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(6, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 6, 4, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG6EI64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg6ei64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(6, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 6, 8, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG7EI8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg7ei8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(7, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 7, 1, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG7EI16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg7ei16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(7, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 7, 2, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG7EI32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg7ei32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(7, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 7, 4, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG7EI64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg7ei64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(7, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 7, 8, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG8EI8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg8ei8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(8, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 8, 1, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG8EI16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg8ei16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(8, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 8, 2, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG8EI32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg8ei32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(8, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 8, 4, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSOXSEG8EI64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsoxseg8ei64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(8, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 8, 8, sew(), 1);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXEI8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxei8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 1, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 1, 1, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXEI16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxei16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 1, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 1, 2, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXEI32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxei32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 1, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 1, 4, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXEI64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxei64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 1, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 1, 8, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG2EI8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg2ei8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 2, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 2, 1, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG2EI16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg2ei16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 2, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 2, 2, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG2EI32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg2ei32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 2, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 2, 4, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG2EI64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg2ei64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 2, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 2, 8, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG3EI8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg3ei8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 3, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 3, 1, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG3EI16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg3ei16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 3, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 3, 2, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG3EI32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg3ei32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 3, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 3, 4, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG3EI64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg3ei64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 3, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 3, 8, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG4EI8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg4ei8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 4, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 4, 1, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG4EI16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg4ei16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 4, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 4, 2, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG4EI32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg4ei32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 4, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 4, 4, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG4EI64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg4ei64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 4, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 4, 8, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG5EI8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg5ei8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 5, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 5, 1, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG5EI16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg5ei16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 5, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 5, 2, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG5EI32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg5ei32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 5, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 5, 4, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG5EI64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg5ei64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 5, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 5, 8, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG6EI8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg6ei8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 6, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 6, 1, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG6EI16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg6ei16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 6, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 6, 2, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG6EI32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg6ei32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 6, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 6, 4, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG6EI64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg6ei64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 6, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 6, 8, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG7EI8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg7ei8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 7, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 7, 1, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG7EI16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg7ei16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 7, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 7, 2, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG7EI32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg7ei32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 7, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 7, 4, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG7EI64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg7ei64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 7, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 7, 8, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG8EI8__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg8ei8.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 8, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 8, 1, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG8EI16__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg8ei16.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 8, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 8, 2, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG8EI32__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg8ei32.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 8, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 8, 4, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VLUXSEG8EI64__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vluxseg8ei64.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_load(vd, vm, 8, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vlxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vd, *(X+rs1), vs2, 8, 8, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXEI8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxei8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(1, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 1, 1, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXEI16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxei16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(1, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 1, 2, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXEI32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxei32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(1, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 1, 4, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXEI64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxei64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(1, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 1, 8, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG2EI8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg2ei8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(2, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 2, 1, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG2EI16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg2ei16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(2, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 2, 2, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG2EI32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg2ei32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(2, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 2, 4, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG2EI64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg2ei64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(2, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 2, 8, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG3EI8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg3ei8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(3, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 3, 1, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG3EI16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg3ei16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(3, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 3, 2, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG3EI32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg3ei32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(3, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 3, 4, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG3EI64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg3ei64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(3, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 3, 8, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG4EI8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg4ei8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(4, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 4, 1, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG4EI16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg4ei16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(4, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 4, 2, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG4EI32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg4ei32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(4, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 4, 4, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG4EI64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg4ei64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(4, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 4, 8, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG5EI8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg5ei8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(5, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 5, 1, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG5EI16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg5ei16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(5, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 5, 2, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG5EI32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg5ei32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(5, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 5, 4, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG5EI64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg5ei64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(5, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 5, 8, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG6EI8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg6ei8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(6, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 6, 1, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG6EI16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg6ei16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(6, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 6, 2, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG6EI32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg6ei32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(6, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 6, 4, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG6EI64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg6ei64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(6, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 6, 8, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG7EI8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg7ei8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(7, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 7, 1, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG7EI16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg7ei16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(7, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 7, 2, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG7EI32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg7ei32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(7, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 7, 4, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG7EI64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg7ei64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(7, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 7, 8, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG8EI8__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg8ei8.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 8;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(8, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 8, 1, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG8EI16__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg8ei16.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 16;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(8, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 8, 2, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG8EI32__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg8ei32.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 32;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(8, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 8, 4, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUXSEG8EI64__V: {
                    uint8_t vs3 = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    uint8_t mew = ((bit_sub<28,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vs3}, ({rs1}), {vs2}, {vm}", fmt::arg("mnemonic", "vsuxseg8ei64.v"),
                            fmt::arg("vs3", vname(vs3)), fmt::arg("rs1", name(rs1)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t EEW = 64;
                                        int8_t EMUL_pow = (int8_t)sext<3>(((uint16_t)(get_pow(EEW)) - (uint16_t)(get_sew_pow()) + (int16_t)(get_lmul_pow())));
                                        if(illegal_indexed_store(8, EEW, EMUL_pow, get_lmul_pow())) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vstart = (uint32_t)vsxseg(this->get_arch(), (uint8_t*)V, *vl, *vstart, *vtype, vm, vs3, *(X+rs1), vs2, 8, 8, sew(), 0);
                                            }
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VADD__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vadd.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        if(illegal_normal(vd, vm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_imm_op((uint8_t*)V, 0, 3, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int8_t)sext<5>(simm), sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VADD__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vadd.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        if(illegal_normal(vd, vm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_vector_op((uint8_t*)V, 0, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VADD__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vadd.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_imm_op((uint8_t*)V, 0, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUB__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vsub.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        if(illegal_normal(vd, vm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_vector_op((uint8_t*)V, 2, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSUB__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vsub.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_imm_op((uint8_t*)V, 2, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VRSUB__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vrsub.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        if(illegal_normal(vd, vm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_imm_op((uint8_t*)V, 3, 3, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int8_t)sext<5>(simm), sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VRSUB__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vrsub.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_imm_op((uint8_t*)V, 3, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWADDU__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vwaddu.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_vector_wv((uint8_t*)V, 48, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWADDU__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vwaddu.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                                        int8_t LMUL_pow = get_lmul_pow();
                                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                vector_imm_wv((uint8_t*)V, 48, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWSUBU__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vwsubu.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_vector_wv((uint8_t*)V, 50, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWSUBU__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vwsubu.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                                        int8_t LMUL_pow = get_lmul_pow();
                                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                vector_imm_wv((uint8_t*)V, 50, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWADD__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vwadd.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_vector_wv((uint8_t*)V, 49, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWADD__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vwadd.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                                        int8_t LMUL_pow = get_lmul_pow();
                                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                vector_imm_wv((uint8_t*)V, 49, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWSUB__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vwsub.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_vector_wv((uint8_t*)V, 51, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWSUB__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vwsub.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                                        int8_t LMUL_pow = get_lmul_pow();
                                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                vector_imm_wv((uint8_t*)V, 51, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWADDU__WV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vwaddu.wv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) | ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_vector_ww((uint8_t*)V, 52, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWADDU__WX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vwaddu.wx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                                        int8_t LMUL_pow = get_lmul_pow();
                                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                vector_imm_ww((uint8_t*)V, 52, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWSUBU__WV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vwsubu.wv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) | ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_vector_ww((uint8_t*)V, 54, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWSUBU__WX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vwsubu.wx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                                        int8_t LMUL_pow = get_lmul_pow();
                                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                vector_imm_ww((uint8_t*)V, 54, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWADD__WV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vwadd.wv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) | ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_vector_ww((uint8_t*)V, 53, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWADD__WX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vwadd.wx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                                        int8_t LMUL_pow = get_lmul_pow();
                                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                vector_imm_ww((uint8_t*)V, 53, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWSUB__WV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vwsub.wv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) | ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_vector_ww((uint8_t*)V, 55, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWSUB__WX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vwsub.wx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                                        int8_t LMUL_pow = get_lmul_pow();
                                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                vector_imm_ww((uint8_t*)V, 55, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VZEXT__VF2: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vzext.vf2"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW_pow = get_sew_pow();
                        uint8_t SEW = (uint8_t)(1 << SEW_pow);
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_target = (uint8_t)(SEW / 2);
                        int8_t LMUL_pow_target = LMUL_pow - 1;
                        if(illegal_variable_width(vd, vm, SEW_target, LMUL_pow_target) || ! valid_reg_overlap(vs2, vd, LMUL_pow_target, LMUL_pow)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_extend((uint8_t*)V, 6, *vl, *vstart, *vtype, vm, vd, vs2, SEW_pow, 1);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSEXT__VF2: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vsext.vf2"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW_pow = get_sew_pow();
                        uint8_t SEW = (uint8_t)(1 << SEW_pow);
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_target = (uint8_t)(SEW / 2);
                        int8_t LMUL_pow_target = LMUL_pow - 1;
                        if(illegal_variable_width(vd, vm, SEW_target, LMUL_pow_target) || ! valid_reg_overlap(vs2, vd, LMUL_pow_target, LMUL_pow)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_extend((uint8_t*)V, 7, *vl, *vstart, *vtype, vm, vd, vs2, SEW_pow, 1);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VZEXT__VF4: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vzext.vf4"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW_pow = get_sew_pow();
                        uint8_t SEW = (uint8_t)(1 << SEW_pow);
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_target = (uint8_t)(SEW / 4);
                        int8_t LMUL_pow_target = LMUL_pow - 2;
                        if(illegal_variable_width(vd, vm, SEW_target, LMUL_pow_target) || ! valid_reg_overlap(vs2, vd, LMUL_pow_target, LMUL_pow)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_extend((uint8_t*)V, 4, *vl, *vstart, *vtype, vm, vd, vs2, SEW_pow, 2);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSEXT__VF4: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vsext.vf4"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW_pow = get_sew_pow();
                        uint8_t SEW = (uint8_t)(1 << SEW_pow);
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_target = (uint8_t)(SEW / 4);
                        int8_t LMUL_pow_target = LMUL_pow - 2;
                        if(illegal_variable_width(vd, vm, SEW_target, LMUL_pow_target) || ! valid_reg_overlap(vs2, vd, LMUL_pow_target, LMUL_pow)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_extend((uint8_t*)V, 5, *vl, *vstart, *vtype, vm, vd, vs2, SEW_pow, 2);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VZEXT__VF8: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vzext.vf8"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW_pow = get_sew_pow();
                        uint8_t SEW = (uint8_t)(1 << SEW_pow);
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_target = (uint8_t)(SEW / 8);
                        int8_t LMUL_pow_target = LMUL_pow - 3;
                        if(illegal_variable_width(vd, vm, SEW_target, LMUL_pow_target) || ! valid_reg_overlap(vs2, vd, LMUL_pow_target, LMUL_pow)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_extend((uint8_t*)V, 2, *vl, *vstart, *vtype, vm, vd, vs2, SEW_pow, 3);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSEXT__VF8: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vsext.vf8"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW_pow = get_sew_pow();
                        uint8_t SEW = (uint8_t)(1 << SEW_pow);
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_target = (uint8_t)(SEW / 8);
                        int8_t LMUL_pow_target = LMUL_pow - 3;
                        if(illegal_variable_width(vd, vm, SEW_target, LMUL_pow_target) || ! valid_reg_overlap(vs2, vd, LMUL_pow_target, LMUL_pow)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_extend((uint8_t*)V, 3, *vl, *vstart, *vtype, vm, vd, vs2, SEW_pow, 3);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VADC__VVM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, v0", fmt::arg("mnemonic", "vadc.vvm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_masked(vd)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_carry((uint8_t*)V, 16, 0, *vl, *vstart, *vtype, vd, vs2, vs1, sew(), 1);
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VADC__VXM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, v0", fmt::arg("mnemonic", "vadc.vxm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_vd_masked(vd)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_carry((uint8_t*)V, 16, 4, *vl, *vstart, *vtype, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew(), 1);
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VADC__VIM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, v0", fmt::arg("mnemonic", "vadc.vim"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_carry((uint8_t*)V, 16, 3, *vl, *vstart, *vtype, vd, vs2, (int32_t)(int8_t)sext<5>(simm), sew(), 1);
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMADC__VVM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, v0", fmt::arg("mnemonic", "vmadc.vvm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            carry_vector_vector_op((uint8_t*)V, 17, *vl, *vstart, *vtype, 0, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMADC__VXM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, v0", fmt::arg("mnemonic", "vmadc.vxm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            carry_vector_imm_op((uint8_t*)V, 17, *vl, *vstart, *vtype, 0, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMADC__VIM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, v0", fmt::arg("mnemonic", "vmadc.vim"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            carry_vector_imm_op((uint8_t*)V, 17, *vl, *vstart, *vtype, 0, vd, vs2, (int32_t)(int8_t)sext<5>(simm), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMADC__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}", fmt::arg("mnemonic", "vmadc.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            carry_vector_vector_op((uint8_t*)V, 17, *vl, *vstart, *vtype, 1, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMADC__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}", fmt::arg("mnemonic", "vmadc.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            carry_vector_imm_op((uint8_t*)V, 17, *vl, *vstart, *vtype, 1, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMADC__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}", fmt::arg("mnemonic", "vmadc.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            carry_vector_imm_op((uint8_t*)V, 17, *vl, *vstart, *vtype, 1, vd, vs2, (int32_t)(int8_t)sext<5>(simm), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSBC__VVM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, v0", fmt::arg("mnemonic", "vsbc.vvm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_masked(vd)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_carry((uint8_t*)V, 18, 0, *vl, *vstart, *vtype, vd, vs2, vs1, sew(), - 1);
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSBC__VXM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, v0", fmt::arg("mnemonic", "vsbc.vxm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_vd_masked(vd)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_carry((uint8_t*)V, 18, 4, *vl, *vstart, *vtype, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew(), - 1);
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSBC__VVM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, v0", fmt::arg("mnemonic", "vmsbc.vvm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            carry_vector_vector_op((uint8_t*)V, 19, *vl, *vstart, *vtype, 0, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSBC__VXM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, v0", fmt::arg("mnemonic", "vmsbc.vxm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            carry_vector_imm_op((uint8_t*)V, 19, *vl, *vstart, *vtype, 0, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSBC__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}", fmt::arg("mnemonic", "vmsbc.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            carry_vector_vector_op((uint8_t*)V, 19, *vl, *vstart, *vtype, 1, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSBC__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}", fmt::arg("mnemonic", "vmsbc.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            carry_vector_imm_op((uint8_t*)V, 19, *vl, *vstart, *vtype, 1, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VAND__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vand.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 9, 3, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int8_t)sext<5>(simm), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VAND__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vand.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 9, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VAND__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vand.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 9, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VOR__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vor.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 10, 3, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int8_t)sext<5>(simm), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VOR__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vor.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 10, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VOR__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vor.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 10, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VXOR__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vxor.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 11, 3, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int8_t)sext<5>(simm), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VXOR__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vxor.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 11, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VXOR__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vxor.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 11, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSLL__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t imm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {imm}, {vm}", fmt::arg("mnemonic", "vsll.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("imm", imm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 37, 3, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(uint32_t)imm, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSLL__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vsll.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 37, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSLL__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vsll.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 37, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(uint32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSRL__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t imm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {imm}, {vm}", fmt::arg("mnemonic", "vsrl.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("imm", imm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 40, 3, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(uint32_t)imm, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSRL__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vsrl.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 40, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSRL__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vsrl.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 40, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(uint32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSRA__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t imm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {imm}, {vm}", fmt::arg("mnemonic", "vsra.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("imm", imm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 41, 3, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(uint32_t)imm, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSRA__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vsra.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 41, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSRA__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vsra.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 41, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(uint32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VNSRL__WI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vnsrl.wi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! (valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_imm_vw((uint8_t*)V, 44, 3, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(uint32_t)simm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VNSRL__WV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vnsrl.wv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! (valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_vector_vw((uint8_t*)V, 44, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VNSRL__WX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vnsrl.wx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                                        int8_t LMUL_pow = get_lmul_pow();
                                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! (valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                vector_imm_vw((uint8_t*)V, 44, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(uint32_t)*(X+rs1), sew());
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VNSRA__WI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vnsra.wi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! (valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_imm_vw((uint8_t*)V, 45, 3, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(uint32_t)simm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VNSRA__WV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vnsra.wv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! (valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_vector_vw((uint8_t*)V, 45, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VNSRA__WX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vnsra.wx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                                        int8_t LMUL_pow = get_lmul_pow();
                                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! (valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                vector_imm_vw((uint8_t*)V, 45, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(uint32_t)*(X+rs1), sew());
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSEQ__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vmseq.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_imm_op((uint8_t*)V, 24, 3, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int8_t)sext<5>(simm), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSEQ__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vmseq.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_vector_op((uint8_t*)V, 24, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSEQ__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmseq.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_imm_op((uint8_t*)V, 24, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSNE__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vmsne.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_imm_op((uint8_t*)V, 25, 3, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int8_t)sext<5>(simm), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSNE__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vmsne.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_vector_op((uint8_t*)V, 25, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSNE__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmsne.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_imm_op((uint8_t*)V, 25, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSLTU__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vmsltu.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_vector_op((uint8_t*)V, 26, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSLTU__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmsltu.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_imm_op((uint8_t*)V, 26, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSLT__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vmslt.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_vector_op((uint8_t*)V, 27, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSLT__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmslt.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_imm_op((uint8_t*)V, 27, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSLEU__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vmsleu.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_imm_op((uint8_t*)V, 28, 3, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int8_t)sext<5>(simm), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSLEU__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vmsleu.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_vector_op((uint8_t*)V, 28, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSLEU__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmsleu.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_imm_op((uint8_t*)V, 28, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSLE__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vmsle.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_imm_op((uint8_t*)V, 29, 3, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int8_t)sext<5>(simm), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSLE__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vmsle.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_vector_op((uint8_t*)V, 29, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSLE__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmsle.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_imm_op((uint8_t*)V, 29, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSGTU__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vmsgtu.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_imm_op((uint8_t*)V, 30, 3, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int8_t)sext<5>(simm), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSGTU__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmsgtu.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_imm_op((uint8_t*)V, 30, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSGT__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vmsgt.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_imm_op((uint8_t*)V, 31, 3, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int8_t)sext<5>(simm), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSGT__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmsgt.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_vector_imm_op((uint8_t*)V, 31, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMINU__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm},", fmt::arg("mnemonic", "vminu.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 4, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMINU__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm},", fmt::arg("mnemonic", "vminu.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 4, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMIN__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm},", fmt::arg("mnemonic", "vmin.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 5, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMIN__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm},", fmt::arg("mnemonic", "vmin.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 5, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMAXU__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm},", fmt::arg("mnemonic", "vmaxu.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 6, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMAXU__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm},", fmt::arg("mnemonic", "vmaxu.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 6, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMAX__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm},", fmt::arg("mnemonic", "vmax.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 7, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMAX__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm},", fmt::arg("mnemonic", "vmax.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 7, 4, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMUL__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10}  {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vmul.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 37, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMUL__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10}  {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmul.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 37, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMULH__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10}  {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vmulh.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 39, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMULH__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10}  {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmulh.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 39, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMULHU__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10}  {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vmulhu.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 36, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMULHU__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10}  {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmulhu.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 36, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMULHSU__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10}  {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vmulhsu.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 38, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMULHSU__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10}  {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmulhsu.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 38, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VDIVU__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vdivu.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 32, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VDIVU__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vdivu.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 32, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VDIV__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vdiv.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 33, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VDIV__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vdiv.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 33, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VREMU__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vremu.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 34, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VREMU__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vremu.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 34, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VREM__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vrem.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 35, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VREM__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vrem.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 35, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWMUL__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vwmul.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_vector_wv((uint8_t*)V, 59, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWMUL__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vwmul.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                                        int8_t LMUL_pow = get_lmul_pow();
                                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                vector_imm_wv((uint8_t*)V, 59, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWMULU__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vwmulu.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_vector_wv((uint8_t*)V, 56, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWMULU__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vwmulu.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                                        int8_t LMUL_pow = get_lmul_pow();
                                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                vector_imm_wv((uint8_t*)V, 56, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWMULSU__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vwmulsu.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_vector_wv((uint8_t*)V, 58, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWMULSU__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vwmulsu.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                                        int8_t LMUL_pow = get_lmul_pow();
                                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                vector_imm_wv((uint8_t*)V, 58, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMACC__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vmacc.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 45, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMACC__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmacc.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 45, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VNMSAC__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vnmsac.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 47, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VNMSAC__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vnmsac.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 47, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMADD__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vmadd.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 41, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMADD__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmadd.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 41, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VNMSUB__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vnmsub.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_op((uint8_t*)V, 43, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VNMSUB__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vnmsub.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_op((uint8_t*)V, 43, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWMACCU__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vwmaccu.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_vector_wv((uint8_t*)V, 60, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWMACCU__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vwmaccu.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                                        int8_t LMUL_pow = get_lmul_pow();
                                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                vector_imm_wv((uint8_t*)V, 60, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWMACC__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vwmacc.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_vector_wv((uint8_t*)V, 61, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWMACC__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vwmacc.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                                        int8_t LMUL_pow = get_lmul_pow();
                                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                vector_imm_wv((uint8_t*)V, 61, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWMACCSU__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vwmaccsu.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_vector_wv((uint8_t*)V, 63, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWMACCSU__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vwmaccsu.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                                        int8_t LMUL_pow = get_lmul_pow();
                                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                vector_imm_wv((uint8_t*)V, 63, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWMACCUS__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vwmaccus.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                                        int8_t LMUL_pow = get_lmul_pow();
                                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                vector_imm_wv((uint8_t*)V, 62, 6, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMERGE__VIM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}", fmt::arg("mnemonic", "vmerge.vim"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_masked(vd)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_merge((uint8_t*)V, *vl, *vstart, *vtype, 0, vd, vs2, (uint32_t)(int32_t)(int8_t)sext<5>(simm), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMERGE__VVM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}", fmt::arg("mnemonic", "vmerge.vvm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_masked(vd)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_merge((uint8_t*)V, *vl, *vstart, *vtype, 0, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMERGE__VXM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}", fmt::arg("mnemonic", "vmerge.vxm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_vd_masked(vd)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_merge((uint8_t*)V, *vl, *vstart, *vtype, 0, vd, vs2, (uint32_t)(int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMV__V__I: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {simm}", fmt::arg("mnemonic", "vmv.v.i"),
                            fmt::arg("vd", vname(vd)), fmt::arg("simm", simm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_merge((uint8_t*)V, *vl, *vstart, *vtype, 1, vd, 0, (uint32_t)(int32_t)(int8_t)sext<5>(simm), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMV__V__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs1}", fmt::arg("mnemonic", "vmv.v.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs1", vname(vs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_vector_merge((uint8_t*)V, *vl, *vstart, *vtype, 1, vd, 0, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMV__V__X: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {rs1}", fmt::arg("mnemonic", "vmv.v.x"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_imm_merge((uint8_t*)V, *vl, *vstart, *vtype, 1, vd, 0, (uint32_t)(int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSADDU__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vsaddu.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vxsat = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxsat]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            *vxsat |= sat_vector_imm_op((uint8_t*)V, 32, 3, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, (int32_t)(int8_t)sext<5>(simm), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSADDU__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vsaddu.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vxsat = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxsat]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            *vxsat |= sat_vector_vector_op((uint8_t*)V, 32, 0, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSADDU__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vsaddu.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vxsat = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxsat]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            *vxsat |= sat_vector_imm_op((uint8_t*)V, 32, 4, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSADD__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vsadd.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vxsat = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxsat]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            *vxsat |= sat_vector_imm_op((uint8_t*)V, 33, 3, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, (int32_t)(int8_t)sext<5>(simm), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSADD__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vsadd.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vxsat = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxsat]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            *vxsat |= sat_vector_vector_op((uint8_t*)V, 33, 0, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSADD__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vsadd.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vxsat = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxsat]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            *vxsat |= sat_vector_imm_op((uint8_t*)V, 33, 4, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSUBU__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vssubu.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vxsat = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxsat]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            *vxsat |= sat_vector_vector_op((uint8_t*)V, 34, 0, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSUBU__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vssubu.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vxsat = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxsat]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            *vxsat |= sat_vector_imm_op((uint8_t*)V, 34, 4, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSUB__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vssub.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vxsat = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxsat]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            *vxsat |= sat_vector_vector_op((uint8_t*)V, 35, 0, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSUB__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vssub.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vxsat = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxsat]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            *vxsat |= sat_vector_imm_op((uint8_t*)V, 35, 4, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VAADDU__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vaaddu.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            sat_vector_vector_op((uint8_t*)V, 8, 2, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VAADDU__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vaaddu.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            sat_vector_imm_op((uint8_t*)V, 8, 6, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VAADD__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vaadd.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            sat_vector_vector_op((uint8_t*)V, 9, 2, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VAADD__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vaadd.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            sat_vector_imm_op((uint8_t*)V, 9, 6, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VASUBU__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vasubu.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            sat_vector_vector_op((uint8_t*)V, 10, 2, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VASUBU__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vasubu.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            sat_vector_imm_op((uint8_t*)V, 10, 6, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VASUB__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vasub.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            sat_vector_vector_op((uint8_t*)V, 11, 2, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VASUB__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vasub.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            sat_vector_imm_op((uint8_t*)V, 11, 6, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSMUL__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vsmul.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vxsat = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxsat]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            *vxsat |= sat_vector_vector_op((uint8_t*)V, 39, 0, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSMUL__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vsmul.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vxsat = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxsat]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            *vxsat |= sat_vector_imm_op((uint8_t*)V, 39, 4, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSRL__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vssrl.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            sat_vector_imm_op((uint8_t*)V, 42, 3, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, (int32_t)(uint32_t)simm, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSRL__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vssrl.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            sat_vector_vector_op((uint8_t*)V, 42, 0, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSRL__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vssrl.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            sat_vector_imm_op((uint8_t*)V, 42, 4, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, (int32_t)(uint32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSRA__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vssra.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            sat_vector_imm_op((uint8_t*)V, 43, 3, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, (int32_t)(uint32_t)simm, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSRA__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vssra.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            sat_vector_vector_op((uint8_t*)V, 43, 0, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSSRA__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vssra.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            sat_vector_imm_op((uint8_t*)V, 43, 4, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, (int32_t)(uint32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VNCLIPU__WI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vnclipu.wi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vxsat = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxsat]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! (valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                *vxsat |= sat_vector_imm_vw((uint8_t*)V, 46, 3, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, (int32_t)(uint32_t)simm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VNCLIPU__WV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vnclipu.wv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vxsat = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxsat]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! (valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                *vxsat |= sat_vector_vector_vw((uint8_t*)V, 46, 0, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VNCLIPU__WX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vnclipu.wx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vxsat = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxsat]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                                        int8_t LMUL_pow = get_lmul_pow();
                                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! (valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vxsat |= sat_vector_imm_vw((uint8_t*)V, 46, 4, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, (int32_t)(uint32_t)*(X+rs1), sew());
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VNCLIP__WI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vnclip.wi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vxsat = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxsat]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! (valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                *vxsat |= sat_vector_imm_vw((uint8_t*)V, 47, 3, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, (int32_t)(uint32_t)simm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VNCLIP__WV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vnclip.wv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vxsat = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxsat]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! (valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                *vxsat |= sat_vector_vector_vw((uint8_t*)V, 47, 0, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VNCLIP__WX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vnclip.wx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vxsat = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxsat]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vxrm = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vxrm]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                                        int8_t LMUL_pow = get_lmul_pow();
                                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                                        if(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) || ! (valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) {
                                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                        }
                                        else {
                                            if(*vl > *vstart) {
                                                *vxsat |= sat_vector_imm_vw((uint8_t*)V, 47, 4, *vl, *vstart, *vtype, *vxrm, vm, vd, vs2, (int32_t)(uint32_t)*(X+rs1), sew());
                                            }
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VREDSUM__VS: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vredsum.vs"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_reduction()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_red_op((uint8_t*)V, 0, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VREDMAXU__VS: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vredmaxu.vs"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_reduction()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_red_op((uint8_t*)V, 6, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VREDMAX__VS: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vredmax.vs"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_reduction()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_red_op((uint8_t*)V, 7, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VREDMINU__VS: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vredminu.vs"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_reduction()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_red_op((uint8_t*)V, 4, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VREDMIN__VS: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vredmin.vs"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_reduction()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_red_op((uint8_t*)V, 5, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VREDAND__VS: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vredand.vs"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_reduction()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_red_op((uint8_t*)V, 1, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VREDOR__VS: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vredor.vs"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_reduction()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_red_op((uint8_t*)V, 2, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VREDXOR__VS: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vredxor.vs"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_reduction()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_red_op((uint8_t*)V, 3, 2, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWREDSUMU__VS: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vwredsumu.vs"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        if(illegal_reduction_widen(SEW_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_red_wv((uint8_t*)V, 48, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VWREDSUM__VS: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vwredsum.vs"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << get_sew_pow()) & ~1;
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        if(illegal_reduction_widen(SEW_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_red_wv((uint8_t*)V, 49, 0, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFREDOSUM__VS: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfredosum.vs"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_reduction(SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_red_op((uint8_t*)V, 3, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFREDUSUM__VS: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfredusum.vs"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_reduction(SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_red_op((uint8_t*)V, 1, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFREDMAX__VS: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfredmax.vs"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_reduction(SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_red_op((uint8_t*)V, 7, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFREDMIN__VS: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfredmin.vs"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_reduction(SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_red_op((uint8_t*)V, 5, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWREDOSUM__VS: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfwredosum.vs"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        if(illegal_fp_reduction_widen(SEW, rm, SEW_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_red_wv((uint8_t*)V, 51, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWREDUSUM__VS: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfwredusum.vs"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        if(illegal_fp_reduction_widen(SEW, rm, SEW_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_red_wv((uint8_t*)V, 49, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMAND__MM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}", fmt::arg("mnemonic", "vmand.mm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_mask_op((uint8_t*)V, 25, 2, *vl, *vstart, vd, vs2, vs1);
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMNAND__MM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}", fmt::arg("mnemonic", "vmnand.mm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_mask_op((uint8_t*)V, 29, 2, *vl, *vstart, vd, vs2, vs1);
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMANDN__MM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}", fmt::arg("mnemonic", "vmandn.mm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_mask_op((uint8_t*)V, 24, 2, *vl, *vstart, vd, vs2, vs1);
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMXOR__MM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}", fmt::arg("mnemonic", "vmxor.mm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_mask_op((uint8_t*)V, 27, 2, *vl, *vstart, vd, vs2, vs1);
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMOR__MM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}", fmt::arg("mnemonic", "vmor.mm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_mask_op((uint8_t*)V, 26, 2, *vl, *vstart, vd, vs2, vs1);
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMNOR__MM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}", fmt::arg("mnemonic", "vmnor.mm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_mask_op((uint8_t*)V, 30, 2, *vl, *vstart, vd, vs2, vs1);
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMORN__MM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}", fmt::arg("mnemonic", "vmorn.mm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_mask_op((uint8_t*)V, 28, 2, *vl, *vstart, vd, vs2, vs1);
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMXNOR__MM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}", fmt::arg("mnemonic", "vmxnor.mm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            mask_mask_op((uint8_t*)V, 31, 2, *vl, *vstart, vd, vs2, vs1);
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VCPOP__M: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {vs2}, {vm},", fmt::arg("mnemonic", "vcpop.m"),
                            fmt::arg("rd", name(rd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || illegal_vd_unmasked() || *vstart != 0) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = vcpop((uint8_t*)V, *vl, *vstart, vm, vs2);
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFIRST__M: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {vs2}, {vm},", fmt::arg("mnemonic", "vfirst.m"),
                            fmt::arg("rd", name(rd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rd >= traits::RFS || illegal_vd_unmasked() || *vstart != 0) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(rd != 0) {
                                            *(X+rd) = vfirst((uint8_t*)V, *vl, *vstart, vm, vs2);
                                            *vstart = 0;
                                        }
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSBF__M: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vmsbf.m"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked() || *vstart != 0 || vd == vs2 || (vm && vd == 0)) {
                                        raise(0, 2);
                                    }
                                    else {
                                        mask_set_op((uint8_t*)V, 1, *vl, *vstart, vm, vd, vs2);
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSIF__M: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vmsif.m"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked() || *vstart != 0 || vd == vs2 || (vm && vd == 0)) {
                                        raise(0, 2);
                                    }
                                    else {
                                        mask_set_op((uint8_t*)V, 3, *vl, *vstart, vm, vd, vs2);
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMSOF__M: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vmsof.m"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked() || *vstart != 0 || vd == vs2 || (vm && vd == 0)) {
                                        raise(0, 2);
                                    }
                                    else {
                                        mask_set_op((uint8_t*)V, 2, *vl, *vstart, vm, vd, vs2);
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VIOTA__M: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10}  {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "viota.m"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_vd_unmasked() || *vstart != 0 || vd == vs2 || (vm && vd == 0)) {
                                        raise(0, 2);
                                    }
                                    else {
                                        viota((uint8_t*)V, *vl, *vstart, *vtype, vm, vd, vs2, sew());
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VID__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vm},", fmt::arg("mnemonic", "vid.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        vid((uint8_t*)V, *vl, *vstart, *vtype, vm, vd, sew());
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMV__S__X: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10}  {vd}, {rs1}", fmt::arg("mnemonic", "vmv.s.x"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", name(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_vd_unmasked()) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            scalar_to_vector((uint8_t*)V, *vtype, vd, (int32_t)(int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMV__X__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {vs2}", fmt::arg("mnemonic", "vmv.x.s"),
                            fmt::arg("rd", name(rd)), fmt::arg("vs2", vname(vs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        if(rd >= traits::RFS || illegal_vd_unmasked()) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(rd != 0) {
                                *(X+rd) = scalar_from_vector((uint8_t*)V, *vtype, vs2, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSLIDEUP__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vslideup.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm) || vs2 == vd) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_slideup((uint8_t*)V, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)simm, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSLIDEUP__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vslideup.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm) || vs2 == vd) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_slideup((uint8_t*)V, *vl, *vstart, *vtype, vm, vd, vs2, *(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSLIDEDOWN__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vslidedown.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_slidedown((uint8_t*)V, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)simm, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSLIDEDOWN__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vslidedown.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_slidedown((uint8_t*)V, *vl, *vstart, *vtype, vm, vd, vs2, *(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSLIDE1UP__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vslide1up.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm) || vs2 == vd) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_slide1up((uint8_t*)V, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VSLIDE1DOWN__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vslide1down.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm)) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_slide1down((uint8_t*)V, *vl, *vstart, *vtype, vm, vd, vs2, (int32_t)*(X+rs1), sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VRGATHER__VI: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t simm = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {simm}, {vm}", fmt::arg("mnemonic", "vrgather.vi"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("simm", simm), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm) || vs2 == vd) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        vector_imm_gather((uint8_t*)V, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)simm, sew());
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VRGATHER__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vrgather.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm) || vs1 == vd || vs2 == vd) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        vector_vector_gather((uint8_t*)V, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VRGATHER__VX: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vrgather.vx"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", name(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* X = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::X0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(rs1 >= traits::RFS || illegal_normal(vd, vm) || vs2 == vd) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        vector_imm_gather((uint8_t*)V, *vl, *vstart, *vtype, vm, vd, vs2, *(X+rs1), sew());
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VRGATHEREI16__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vrgatherei16.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(illegal_normal(vd, vm) || vs1 == vd || vs2 == vd) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        vector_vector_gatherei16((uint8_t*)V, *vl, *vstart, *vtype, vm, vd, vs2, vs1, sew());
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VCOMPRESS__VM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}", fmt::arg("mnemonic", "vcompress.vm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(*vstart != 0 | vs1 == vd | vs2 == vd | illegal_vd_unmasked()) {
                                        raise(0, 2);
                                    }
                                    else {
                                        if(*vl > *vstart) {
                                            vector_compress((uint8_t*)V, *vl, *vstart, *vtype, vd, vs2, vs1, sew());
                                        }
                                        *vstart = 0;
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMV1R__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}", fmt::arg("mnemonic", "vmv1r.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        vector_whole_move((uint8_t*)V, vd, vs2, 1);
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMV2R__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}", fmt::arg("mnemonic", "vmv2r.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(vd % 2 || vs2 % 2) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        vector_whole_move((uint8_t*)V, vd, vs2, 2);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMV4R__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}", fmt::arg("mnemonic", "vmv4r.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(vd % 4 || vs2 % 4) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        vector_whole_move((uint8_t*)V, vd, vs2, 4);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMV8R__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}", fmt::arg("mnemonic", "vmv8r.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                                    if(vd % 8 || vs2 % 8) {
                                        raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                                    }
                                    else {
                                        vector_whole_move((uint8_t*)V, vd, vs2, 8);
                                    }
                                }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFMV__S__F: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {rs1}", fmt::arg("mnemonic", "vfmv.s.f"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", fname(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_vd_unmasked(SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                scalar_to_vector((uint8_t*)V, *vtype, vd, (int32_t)(uint32_t)*(F+rs1), sew());
                                *vstart = 0;
                            }
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFMV__F__S: {
                    uint8_t rd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {rd}, {vs2}", fmt::arg("mnemonic", "vfmv.f.s"),
                            fmt::arg("rd", fname(rd)), fmt::arg("vs2", vname(vs2)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_vd_unmasked(SEW, rm) || SEW > traits::FLEN) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            *(F+rd) = fp_scalar_from_vector((uint8_t*)V, *vtype, vs2, sew());
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFSLIDE1UP__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfslide1up.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_slide1up((uint8_t*)V, *vl, *vstart, *vtype, vm, vd, vs2, *(F+rs1), sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFSLIDE1DOWN__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfslide1down.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_slide1down((uint8_t*)V, *vl, *vstart, *vtype, vm, vd, vs2, *(F+rs1), sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFADD__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfadd.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_op((uint8_t*)V, 0, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFADD__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfadd.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_op((uint8_t*)V, 0, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFSUB__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfsub.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_op((uint8_t*)V, 2, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFSUB__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfsub.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_op((uint8_t*)V, 2, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFRSUB__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfrsub.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_op((uint8_t*)V, 39, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWADD__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfwadd.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_wv((uint8_t*)V, 48, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWADD__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfwadd.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_wv((uint8_t*)V, 48, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWSUB__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfwsub.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_wv((uint8_t*)V, 50, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWSUB__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfwsub.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_wv((uint8_t*)V, 50, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWADD__WF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfwadd.wf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_ww((uint8_t*)V, 52, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWADD__WV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfwadd.wv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_ww((uint8_t*)V, 52, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWSUB__WF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfwsub.wf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_ww((uint8_t*)V, 54, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWSUB__WV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfwsub.wv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_ww((uint8_t*)V, 54, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFMUL__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfmul.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_op((uint8_t*)V, 36, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFMUL__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm},", fmt::arg("mnemonic", "vfmul.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_op((uint8_t*)V, 36, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFDIV__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfdiv.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_op((uint8_t*)V, 32, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFDIV__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm},", fmt::arg("mnemonic", "vfdiv.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_op((uint8_t*)V, 32, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFRDIV__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfrdiv.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_op((uint8_t*)V, 33, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWMUL__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfwmul.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_wv((uint8_t*)V, 56, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWMUL__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfwmul.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_wv((uint8_t*)V, 56, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFMACC__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfmacc.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_op((uint8_t*)V, 44, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFMACC__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfmacc.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_op((uint8_t*)V, 44, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFNMACC__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfnmacc.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_op((uint8_t*)V, 45, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFNMACC__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfnmacc.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_op((uint8_t*)V, 45, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFMSAC__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfmsac.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_op((uint8_t*)V, 46, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFMSAC__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfmsac.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_op((uint8_t*)V, 46, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFNMSAC__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfnmsac.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_op((uint8_t*)V, 47, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFNMSAC__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfnmsac.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_op((uint8_t*)V, 47, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFMADD__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfmadd.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_op((uint8_t*)V, 40, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFMADD__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfmadd.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_op((uint8_t*)V, 40, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFNMADD__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfnmadd.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_op((uint8_t*)V, 41, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFNMADD__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfnmadd.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_op((uint8_t*)V, 41, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFMSUB__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfmsub.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_op((uint8_t*)V, 42, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFMSUB__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfmsub.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_op((uint8_t*)V, 42, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFNMSUB__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfnmsub.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_op((uint8_t*)V, 43, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFNMSUB__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfnmsub.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_op((uint8_t*)V, 43, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWMACC__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfwmacc.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_wv((uint8_t*)V, 60, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWMACC__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfwmacc.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_wv((uint8_t*)V, 60, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWNMACC__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfwnmacc.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_wv((uint8_t*)V, 61, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWNMACC__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfwnmacc.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_wv((uint8_t*)V, 61, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWMSAC__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfwmsac.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_wv((uint8_t*)V, 62, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWMSAC__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfwmsac.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_wv((uint8_t*)V, 62, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWNMSAC__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfwnmsac.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_wv((uint8_t*)V, 63, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWNMSAC__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfwnmsac.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_wv((uint8_t*)V, 63, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFSQRT__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfsqrt.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_op((uint8_t*)V, 19, 0, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFRSQRT7__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfrsqrt7.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_op((uint8_t*)V, 19, 4, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFREC7__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfrec7.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_op((uint8_t*)V, 19, 5, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFMIN__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfmin.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_op((uint8_t*)V, 4, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFMIN__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfmin.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_op((uint8_t*)V, 4, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFMAX__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfmax.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_op((uint8_t*)V, 6, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFMAX__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfmax.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_op((uint8_t*)V, 6, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFSGNJ__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfsgnj.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_op((uint8_t*)V, 8, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFSGNJ__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfsgnj.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_op((uint8_t*)V, 8, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFSGNJN__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfsgnjn.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_op((uint8_t*)V, 9, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFSGNJN__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfsgnjn.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_op((uint8_t*)V, 9, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFSGNJX__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vfsgnjx.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_imm_op((uint8_t*)V, 10, 5, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFSGNJX__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vfsgnjx.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_vector_op((uint8_t*)V, 10, 1, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMFEQ__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmfeq.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_vd_unmasked(SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                mask_fp_vector_imm_op((uint8_t*)V, 24, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMFEQ__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vmfeq.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_vd_unmasked(SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                mask_fp_vector_vector_op((uint8_t*)V, 24, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMFNE__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmfne.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_vd_unmasked(SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                mask_fp_vector_imm_op((uint8_t*)V, 28, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMFNE__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vmfne.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_vd_unmasked(SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                mask_fp_vector_vector_op((uint8_t*)V, 28, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMFLT__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmflt.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_vd_unmasked(SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                mask_fp_vector_imm_op((uint8_t*)V, 27, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMFLT__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vmflt.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_vd_unmasked(SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                mask_fp_vector_vector_op((uint8_t*)V, 27, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMFLE__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmfle.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_vd_unmasked(SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                mask_fp_vector_imm_op((uint8_t*)V, 25, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMFLE__VV: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vs1}, {vm}", fmt::arg("mnemonic", "vmfle.vv"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vs1", vname(vs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_vd_unmasked(SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                mask_fp_vector_vector_op((uint8_t*)V, 25, *vl, *vstart, *vtype, vm, vd, vs2, vs1, rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMFGT__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmfgt.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_vd_unmasked(SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                mask_fp_vector_imm_op((uint8_t*)V, 29, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VMFGE__VF: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}, {vm}", fmt::arg("mnemonic", "vmfge.vf"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_vd_unmasked(SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                mask_fp_vector_imm_op((uint8_t*)V, 31, *vl, *vstart, *vtype, vm, vd, vs2, (uint32_t)*(F+rs1), rm, sew());
                                uint32_t flags = fget_flags();
                                *FCSR = (*FCSR & ~traits::FFLAG_MASK) | (flags & traits::FFLAG_MASK);
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFCLASS__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfclass.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_op((uint8_t*)V, 19, 16, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFMERGE__VFM: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {rs1}", fmt::arg("mnemonic", "vfmerge.vfm"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("rs1", fname(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_vd_masked(vd, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_imm_merge((uint8_t*)V, *vl, *vstart, *vtype, 0, vd, vs2, (uint32_t)*(F+rs1), sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFMV__V__F: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t rs1 = ((bit_sub<15,5>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {rs1}", fmt::arg("mnemonic", "vfmv.v.f"),
                            fmt::arg("vd", vname(vd)), fmt::arg("rs1", fname(rs1)));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    auto* F = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::F0]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_vd_unmasked(SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                vector_imm_merge((uint8_t*)V, *vl, *vstart, *vtype, 1, vd, 0, (uint32_t)*(F+rs1), sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFCVT__XU__F__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfcvt.xu.f.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_op((uint8_t*)V, 18, 0, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFCVT__X__F__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfcvt.x.f.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_op((uint8_t*)V, 18, 1, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFCVT__RTZ__XU__F__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfcvt.rtz.xu.f.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = 1;
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_op((uint8_t*)V, 18, 6, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFCVT__RTZ__X__F__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfcvt.rtz.x.f.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = 1;
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_op((uint8_t*)V, 18, 7, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFCVT__F__XU__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfcvt.f.xu.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_op((uint8_t*)V, 18, 2, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFCVT__F__X__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfcvt.f.x.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_normal(vd, vm, SEW, rm)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_op((uint8_t*)V, 18, 3, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWCVT__XU__F__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfwcvt.xu.f.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_w((uint8_t*)V, 8, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWCVT__X__F__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfwcvt.x.f.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_w((uint8_t*)V, 9, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWCVT__RTZ__XU__F__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfwcvt.rtz.xu.f.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = 1;
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_w((uint8_t*)V, 14, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWCVT__RTZ__X__F__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfwcvt.rtz.x.f.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = 1;
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_w((uint8_t*)V, 15, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWCVT__F__XU__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfwcvt.f.xu.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_w((uint8_t*)V, 10, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWCVT__F__X__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfwcvt.f.x.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_w((uint8_t*)V, 11, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFWCVT__F__F__V: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfwcvt.f.f.v"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_w((uint8_t*)V, 12, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFNCVT__X__F__W: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfncvt.x.f.w"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_n((uint8_t*)V, 17, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFNCVT__XU__F__W: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfncvt.xu.f.w"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_n((uint8_t*)V, 16, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFNCVT__RTZ__XU__F__W: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfncvt.rtz.xu.f.w"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = 1;
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_n((uint8_t*)V, 22, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFNCVT__RTZ__X__F__W: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfncvt.rtz.x.f.w"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = 1;
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_n((uint8_t*)V, 23, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFNCVT__F__XU__W: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfncvt.f.xu.w"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_n((uint8_t*)V, 18, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFNCVT__F__X__W: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfncvt.f.x.w"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_n((uint8_t*)V, 19, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFNCVT__F__F__W: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfncvt.f.f.w"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_n((uint8_t*)V, 20, *vl, *vstart, *vtype, vm, vd, vs2, rm, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                case arch::traits<ARCH>::opcode_e::VFNCVT__ROD__F__F__W: {
                    uint8_t vd = ((bit_sub<7,5>(instr)));
                    uint8_t vs2 = ((bit_sub<20,5>(instr)));
                    uint8_t vm = ((bit_sub<25,1>(instr)));
                    if(this->disass_enabled){
                        /* generate console output when executing the command */
                        auto mnemonic = fmt::format(
                            "{mnemonic:10} {vd}, {vs2}, {vm}", fmt::arg("mnemonic", "vfncvt.rod.f.f.w"),
                            fmt::arg("vd", vname(vd)), fmt::arg("vs2", vname(vs2)), fmt::arg("vm", vm));
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    // used registers 
                    auto* FCSR = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::FCSR]); 
                    auto* vl = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vl]); 
                    auto* vstart = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vstart]);
                    auto* V = reinterpret_cast<uint64_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::V0]); 
                    auto* vtype = reinterpret_cast<uint32_t*>(this->regs_base_ptr+arch::traits<ARCH>::reg_byte_offsets[arch::traits<ARCH>::vtype]);
                    // calculate next pc value
                    *NEXT_PC = *PC + 4;
                    // execute instruction
                    {
                        uint8_t SEW = (uint8_t)(1 << (get_sew_pow())) & ~1;
                        int8_t LMUL_pow = get_lmul_pow();
                        uint8_t SEW_widen = (uint8_t)((uint16_t)(SEW) * (uint16_t)(2));
                        int8_t LMUL_pow_widen = LMUL_pow + 1;
                        uint8_t rm = bit_sub<5, 7-5+1>(*FCSR);
                        if(illegal_fp_variable_width(vd, vm, SEW, rm, SEW_widen, LMUL_pow_widen) || ! valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow)) {
                            raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                        }
                        else {
                            if(*vl > *vstart) {
                                fp_vector_unary_n((uint8_t*)V, 21, *vl, *vstart, *vtype, vm, vd, vs2, 6, sew());
                            }
                            *vstart = 0;
                        }
                    }
                    break;
                }// @suppress("No break at end of case")
                default: {
                    if(this->disass_enabled){
                        std::string mnemonic = "Illegal Instruction";
                        this->core.disass_output(pc.val, mnemonic);
                    }
                    *NEXT_PC = *PC + ((instr & 3) == 3 ? 4 : 2);
                    raise(0, traits::RV_CAUSE_ILLEGAL_INSTRUCTION);
                }
                }
            }catch(memory_access_exception& e){}
            // post execution stuff
            process_spawn_blocks();
            if(this->sync_exec && POST_SYNC) this->do_sync(POST_SYNC, static_cast<unsigned>(inst_id));
            // if(!this->core.reg.trap_state) // update trap state if there is a pending interrupt
            //    this->core.reg.trap_state =  this->core.reg.pending_trap;
            // trap check
            if(trap_state!=0){
                //In case of Instruction address misaligned (cause = 0 and trapid = 0) need the targeted addr (in tval)
                auto mcause = (trap_state>>16) & 0xff; 
                super::core.enter_trap(trap_state, pc.val, mcause ? instr:tval);
            } else {
                icount++;
                instret++;
            }
            *PC = *NEXT_PC;
            this->core.reg.trap_state =  this->core.reg.pending_trap;
        }
        fetch_count++;
        cycle++;
    }
    return pc;
}

} // namespace rv32gcv

template <>
std::unique_ptr<vm_if> create<arch::rv32gcv>(arch::rv32gcv *core, unsigned short port, bool dump) {
    auto ret = new rv32gcv::vm_impl<arch::rv32gcv>(*core, dump);
    if (port != 0) debugger::server<debugger::gdb_session>::run_server(ret, port);
    return std::unique_ptr<vm_if>(ret);
}
} // namespace interp
} // namespace iss

#include <iss/arch/riscv_hart_m_p.h>
#include <iss/arch/riscv_hart_mu_p.h>
#include <iss/arch/riscv_hart_msu_vp.h>
#include <iss/factory.h>
namespace iss {
namespace {

volatile std::array<bool, 3> dummy = {
        core_factory::instance().register_creator("rv32gcv_msu:interp", [](unsigned port, void* init_data) -> std::tuple<cpu_ptr, vm_ptr>{
            auto* cpu = new iss::arch::riscv_hart_msu_vp<iss::arch::rv32gcv>();
		    auto vm = new interp::rv32gcv::vm_impl<arch::rv32gcv>(*cpu, false);
		    if (port != 0) debugger::server<debugger::gdb_session>::run_server(vm, port);
            if(init_data){
                auto* cb = reinterpret_cast<semihosting_cb_t<arch::traits<arch::rv32gcv>::reg_t>*>(init_data);
                cpu->set_semihosting_callback(*cb);
            }
            return {cpu_ptr{cpu}, vm_ptr{vm}};
        }),
        core_factory::instance().register_creator("rv32gcv_m:interp", [](unsigned port, void* init_data) -> std::tuple<cpu_ptr, vm_ptr>{
            auto* cpu = new iss::arch::riscv_hart_m_p<iss::arch::rv32gcv>();
		    auto vm = new interp::rv32gcv::vm_impl<arch::rv32gcv>(*cpu, false);
		    if (port != 0) debugger::server<debugger::gdb_session>::run_server(vm, port);
            if(init_data){
                auto* cb = reinterpret_cast<semihosting_cb_t<arch::traits<arch::rv32gcv>::reg_t>*>(init_data);
                cpu->set_semihosting_callback(*cb);
            }
            return {cpu_ptr{cpu}, vm_ptr{vm}};
        }),
        core_factory::instance().register_creator("rv32gcv_mu:interp", [](unsigned port, void* init_data) -> std::tuple<cpu_ptr, vm_ptr>{
            auto* cpu = new iss::arch::riscv_hart_mu_p<iss::arch::rv32gcv>();
		    auto vm = new interp::rv32gcv::vm_impl<arch::rv32gcv>(*cpu, false);
		    if (port != 0) debugger::server<debugger::gdb_session>::run_server(vm, port);
            if(init_data){
                auto* cb = reinterpret_cast<semihosting_cb_t<arch::traits<arch::rv32gcv>::reg_t>*>(init_data);
                cpu->set_semihosting_callback(*cb);
            }
            return {cpu_ptr{cpu}, vm_ptr{vm}};
        })
};
}
}
// clang-format on
